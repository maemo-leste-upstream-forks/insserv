Purpose: Reduce verbosity level (drop Loading... messages)
Fixes:   -
Status:  Not yet submitted upstream.
---

Index: insserv/listing.h
===================================================================
--- insserv.orig/listing.h	2009-09-26 22:35:25.000000000 +0200
+++ insserv/listing.h	2009-09-26 22:35:39.000000000 +0200
@@ -283,7 +283,7 @@
 extern const char *const delimeter;
 extern void error(const char *restrict fmt, ...) attribute((noreturn,format(printf,1,2)));
 extern void warn (const char *restrict fmt, ...) attribute((format(printf,1,2)));
-extern void info (const char *restrict fmt, ...) attribute((format(printf,1,2)));
+extern void info (int level, const char *restrict fmt, ...) attribute((format(printf,2,3)));
 extern inline int map_has_runlevels(void) attribute((always_inline));
 extern inline char map_runlevel_to_key(const int runlevel);
 extern inline ushort map_key_to_lvl(const char key);
@@ -312,23 +312,23 @@
 	(unlinkat(d,x,0) != 0 && (errno != EISDIR || unlinkat(d,x,AT_REMOVEDIR) != 0)))) \
 	warn ("can not remove(%s%s): %s\n", rcd, x, strerror(errno)); \
 	else \
-	info("remove service %s/%s%s\n", path, rcd, x); }))
+	info(1, "remove service %s/%s%s\n", path, rcd, x); }))
 #else
 # define xremove(d,x) (__extension__ ({ if ((dryrun ? 0 : (remove(x) != 0))) \
 	warn ("can not remove(%s%s): %s\n", rcd, x, strerror(errno)); \
 	else \
-	info("remove service %s/%s%s\n", path, rcd, x); }))
+	info(1, "remove service %s/%s%s\n", path, rcd, x); }))
 #endif
 #if defined(HAS_symlinkat) && defined(_ATFILE_SOURCE)
 # define xsymlink(d,x,y) (__extension__ ({ if ((dryrun ? 0 : (symlinkat(x, d, y) != 0))) \
 	warn ("can not symlink(%s, %s%s): %s\n", x, rcd, y, strerror(errno)); \
 	else \
-	info("enable service %s -> %s/%s%s\n", x, path, rcd, y); }))
+	info(1, "enable service %s -> %s/%s%s\n", x, path, rcd, y); }))
 #else
 # define xsymlink(d,x,y) (__extension__ ({ if ((dryrun ? 0 : (symlink(x, y) != 0))) \
 	warn ("can not symlink(%s, %s%s): %s\n", x, rcd, y, strerror(errno)); \
 	else \
-	info("enable service %s -> %s/%s%s\n", x, path, rcd, y); }))
+	info(1, "enable service %s -> %s/%s%s\n", x, path, rcd, y); }))
 #endif
 #if defined(HAS_fstatat) && defined(_ATFILE_SOURCE)
 # define xstat(d,x,s)	(__extension__ ({ fstatat(d,x,s, 0); }))
Index: insserv/insserv.c
===================================================================
--- insserv.orig/insserv.c	2009-09-26 22:35:39.000000000 +0200
+++ insserv/insserv.c	2009-09-26 22:35:41.000000000 +0200
@@ -114,8 +114,8 @@
 /* The main line buffer if unique */
 static char buf[LINE_MAX];
 
-/* When to be verbose */
-static boolean verbose = false;
+/* When to be verbose, and what level of verbosity */
+static int verbose = 0;
 
 /* When to be verbose */
 static boolean dryrun = false;
@@ -690,9 +690,9 @@
 
     if (dryrun) {
 #ifdef USE_KILL_IN_BOOT
-	info("dryrun, not creating .depend.boot, .depend.start, .depend.halt, and .depend.stop\n");
+	info(1, "dryrun, not creating .depend.boot, .depend.start, .depend.halt, and .depend.stop\n");
 #else  /* not USE_KILL_IN_BOOT */
-	info("dryrun, not creating .depend.boot, .depend.start, and .depend.stop\n");
+	info(1, "dryrun, not creating .depend.boot, .depend.start, and .depend.stop\n");
 #endif /* not USE_KILL_IN_BOOT */
 	return;
     }
@@ -707,8 +707,8 @@
 	return;
     }
 
-    info("creating .depend.boot\n");
-    info("creating .depend.start\n");
+    info(1, "creating .depend.boot\n");
+    info(1, "creating .depend.start\n");
 
     lsort('S');					/* Sort into start order, set new sorder */
 
@@ -874,9 +874,9 @@
 	return;
     }
 
-    info("creating .depend.halt\n");
+    info(1, "creating .depend.halt\n");
 #endif /* USE_KILL_IN_BOOT */
-    info("creating .depend.stop\n");
+    info(1, "creating .depend.stop\n");
 
     lsort('K');					/* Sort into stop order, set new korder */
 
@@ -1014,9 +1014,9 @@
 /*
  * Print message when verbose is enabled
  */
-void info(const char *fmt, ...) {
+void info(int level, const char *fmt, ...) {
     va_list ap;
-    if (!verbose)
+    if (level > verbose)
 	goto out;
     va_start(ap, fmt);
     _logger(fmt, ap);
@@ -1062,7 +1062,7 @@
 
     if (stat(rcpath, &st) < 0) {
 	if (errno == ENOENT) {
-	    info("creating directory '%s'\n", rcpath);
+	    info(1, "creating directory '%s'\n", rcpath);
 	    if (!dryrun)
 		mkdir(rcpath, (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH));
 	} else
@@ -1190,7 +1190,7 @@
     char *basenamestr = basename(path); /* GNU basename */
     char *retval = is_upstart_job_recursive(path, basenamestr);
     if (retval)
-        info("script '%s' is upstart job\n", basenamestr);
+        info(2, "script '%s' is upstart job\n", basenamestr);
     return retval;
 }
 
@@ -1225,7 +1225,7 @@
 #define description	script_inf.description
 #define interactive	script_inf.interactive
 
-    info("Loading %s\n", path);
+    info(2, "Loading %s\n", path);
 
     if (NULL != (upstart_job = is_upstart_job(path))) {
         char cmd[2048];
@@ -1882,7 +1882,7 @@
     regmatch_t subloc[SUBCONFNUM], *val = (regmatch_t*)0;
     FILE *conf;
 
-    info("Loading %s\n", file);
+    info(2, "Loading %s\n", file);
 
     do {
 	const char * fptr = file;
@@ -2347,10 +2347,10 @@
 		ignore = true;
 		break;
 	    case 'v':
-		verbose = true;
+		verbose ++;
 		break;
 	    case 'n':
-		verbose = true;
+		verbose ++;
 		dryrun = true;
 		break;
 	    case 'p':
