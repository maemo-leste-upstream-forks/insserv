#!/usr/bin/perl
#
# Author: Petter Reinholdtsen
# Date:   2005-08-21
#
# Read LSM init.d headers in SysV init.d scripts, and verify correct
# start order for all runlevels.  It can also provide a graph.
#
# To generate a graph, run it like this
#
#   check-initd-order -g > initorder.dotty && dotty initorder.dotty

use strict;
use warnings;

my $rcbase = "/etc";
#$rcbase = "/opt/ltsp/i386/etc";

my $overridepath = "/usr/share/insserv/overrides";
my $hostoverridepath =  "/etc/insserv/overrides";

my $debug = 0;

my %rcmap =
    (
     'B' => 'rc.boot',
     'S' => 'rcS.d',
     '1' => 'rc1.d',
     '2' => 'rc2.d',
     '3' => 'rc3.d',
     '4' => 'rc4.d',
     '5' => 'rc5.d',
     '6' => 'rc6.d',
     );

# Map packages to system metapackages.  These dependencies should
# probably be more complex
my %sysmap =
    (
     'network'      => '$network',
     'networking'   => '$network',
     'syslog'       => '$syslog',
     'sysklogd'     => '$syslog',
     'mountall'     => '$local_fs',
     'umountfs'     => '$local_fs',
     'mountnfs'     => '$remote_fs',
     'mountnfs-bootclean' => '$remote_fs',
     'umountnfs'    => '$remote_fs',
     'sendsigs'     => '$remote_fs',
     'hwclock'      => '$time',
     'ntpdate'      => '$time',
     'ntp-server'   => '$time',
     'named'        => '$named',
     'dnsmasq'      => '$named',
     'lwresd'       => '$named',
     'bind9'        => '$named',
     'portmap'      => '$portmap',
     );

my %scriptorder;
my %opts;

while($#ARGV >= 0 && ($_ = $ARGV[0]) =~ /^-/) {
        shift @ARGV;
        if (/^-([dgko])$/) { $opts{$1}++; next }
        if (/^-h|--help$/) { &usage; }
        &usage("unknown option");
}

$debug = $opts{'d'};
my $useoverrides = $opts{'o'} ? 0 : 1;

if ($opts{'g'}) {
    graph_generate();
    exit 0;
}

check_bootorder();

sub usage {
    print STDERR "check-initd-order: error: @_\n" if ($#_ >= 0);
    print STDERR <<EOF;
usage: check-initd-order [-dgko]
EOF
    exit 1;
}

# Simple basename implementatin to avoid dependin on File::Basename
# from perl-modules
sub basename {
    my $path = shift;
    $path =~ s%^.*/([^/]+)$%$1%;
    return $path;
}

sub graph_addnode {
    my %lsbinfo = @_;

    unless ($lsbinfo{'provides'}) {
        print STDERR "error: File ". $lsbinfo{'file'} . " is missing the provides header\n";
        $lsbinfo{'provides'} = $lsbinfo{'file'};
    }

    my $key = $opts{'k'} ? 'stop' : 'start';
    my $revkey = $opts{'k'} ? 'stop-after' : 'start-before';
    my @provides = split(/\s+/, $lsbinfo{'provides'});
    for my $name (@provides) {
        if (exists $sysmap{$name}) {
            graph_addnode('provides'      => $sysmap{$name},
                          "required-$key" => $name);
        }
    }

    if (1 < @provides) {
        print STDERR "warning: Unable to properly handle multiple provides: @provides\n";
    }

    my %deps =
        (
         "required-$key" => 'blue',
         "should-$key" => 'springgreen',
         "$revkey" => 'yellow'
         );

    for $key (keys %deps) {
        if (exists $lsbinfo{$key} && $lsbinfo{$key}) {
            my @depends = split(/\s+/, $lsbinfo{$key});
            for my $pkg (@depends) {
                my $color = $deps{$key};
                if ($revkey eq $key) {
                    print "\"$provides[0]\" -> \"$pkg\"[color=$color] ;\n";
                } else {
                    print "\"$pkg\" -> \"$provides[0]\"[color=$color] ;\n";
                }
            }
        }
    }

    print "\"$provides[0]\" [shape=box];\n";
}

sub graph_generate {
    print "# Generating graph\n";
    print <<EOF;
digraph packages {
rankdir=LR;
concentrate=true;
EOF
    my @dirs = $opts{'k'} ? $rcmap{6} : ($rcmap{S}, $rcmap{2});
    for my $rcdir (@dirs) {
        chdir "$rcbase/$rcdir/.";
        my @scripts = $opts{'k'} ? <K*> : <S*>;
        for my $script (@scripts) {
            my $lsbinforef = load_lsb_tags("$rcbase/$rcdir/$script",
                                           $useoverrides);

            unless (defined $lsbinforef) {
                print STDERR "warning: LSB header missing in $rcbase/$rcdir/$script\n";
                $lsbinforef = {'provides'       => $script,
                               'required-start' => '$remote_fs $syslog',
                               'required-stop'  => '$remote_fs $syslog'};
            }
            my %lsbinfo = %{$lsbinforef};
            graph_addnode %lsbinfo;
        }
    }
    print <<EOF;
}
EOF
}

sub check_bootorder {
    my $bootorder = 0;
    my @dirs = $opts{'k'} ? $rcmap{6} : ($rcmap{S}, $rcmap{2});
    for my $rcdir (@dirs) {
        chdir "$rcbase/$rcdir/.";
        my @scripts = $opts{'k'} ? <K*> : <S*>;

        if ($opts{'k'}) {
            $scriptorder{'K'}{'$all'} = 1;
        } else {
            # Calculate script order for the script before the scripts
            # with the last boot sequence number.
            my $tmpbootorder = 0;
            my $allorder = 0;
            my $maxorder = 0;
            my $maxbootorder = 0;
            for my $script (@scripts) {
                $tmpbootorder++;
                my ($tag, $order, $name) = $script =~ m/^(.)(\d{2})(.+)$/;
                if ($order > $maxorder) {
                    $allorder = $maxbootorder;
                    $maxbootorder = $tmpbootorder;
                    $maxorder = $order;
                }
            }
            $scriptorder{'S'}{'$all'} = $allorder;
        }
        for my $script (@scripts) {
            $bootorder++;
            my ($tag, $order, $name) = $script =~ m/^(.)(\d{2})(.+)$/;

            $scriptorder{$tag}{$name} = $bootorder;
            $scriptorder{$tag}{$sysmap{$name}} = $bootorder
                if (exists $sysmap{$name});

#           print "$script\n";
#           print "T: $tag O: $order N: $name\n";
            my $lsbinforef = load_lsb_tags("$rcbase/$rcdir/$script",
                                           $useoverrides);

            unless (defined $lsbinforef) {
                print STDERR "LSB header missing in $rcbase/$rcdir/$script\n";
                next;
            }
            my %lsbinfo = %{$lsbinforef};

            for my $provide (split(/\s+/, $lsbinfo{'provides'})) {
                $scriptorder{$tag}{$provide} = $bootorder;
                $scriptorder{$tag}{$sysmap{$provide}} = $bootorder
                    if (exists $sysmap{$provide});
            }

            if ('S' eq $tag) {
                if ($lsbinfo{'required-start'}) {
                    my @depends = split(/\s+/, $lsbinfo{'required-start'});
                    for my $dep (@depends) {
                        unless (exists $scriptorder{$tag}{$dep}
                                and $scriptorder{$tag}{$dep} < $bootorder) {
                            my $deporder;
                            if (exists $scriptorder{$tag}{$dep}) {
                                $deporder = $scriptorder{$tag}{$dep}
                            } else {
                                $deporder = "?";
                            }
                            print "Incorrect order " .
                                "$dep\@$deporder > $name\@$order\n";
                        }
                    }
                }
            }
            if ('K' eq $tag) {
            }
        }
    }
}

sub load_lsb_tags {
    my ($initfile, $useoverrides) = @_;
    my $lsbinforef = load_lsb_tags_from_file($initfile);

    if ($useoverrides) {
        # Try override file
        $initfile = readlink($initfile) if (-l $initfile);
        my $basename = basename($initfile);

        # Only read shipped override file when initscript does not
        # contain LSB tags.
        if (! defined($lsbinforef) && -f "$overridepath/$basename") {
            print STDERR "Override $overridepath/$basename\n" if $debug;
            $lsbinforef = load_lsb_tags_from_file("$overridepath/$basename");
        }

        # Always read the host override in $hostoverridepath.
        if (-f "$hostoverridepath/$basename") {
            print STDERR "Override $hostoverridepath/$basename\n" if $debug;
            $lsbinforef = load_lsb_tags_from_file("$hostoverridepath/$basename");
        }

    }
    return $lsbinforef;
}

sub load_lsb_tags_from_file {
    my ($file) = @_;
    print STDERR "Loading $file\n" if $debug;
    ### BEGIN INIT INFO
    # Provides:          xdebconfigurator
    # Required-Start:    $syslog
    # Required-Stop:     $syslog
    # Default-Start:     2 3 4 5
    # Default-Stop:      1 6
    # Short-Description: Genererate xfree86 configuration at boot time
    # Description:       Preseed X configuration and use dexconf to
    #                    genereate a new configuration file.
    ### END INIT INFO
    unless (open(FILE, "<$file")) {
        warn "error: Unable to read $file";
        return;
    }
    my $found = 0;
    my ($provides, $requiredstart, $requiredstop, $shouldstart, $shouldstop);
    my ($startbefore, $stopafter);
    while (<FILE>) {
        chomp;
        $found = 1 if (m/\#\#\# BEGIN INIT INFO/);
        next unless $found;
        last if (m/\#\#\# END INIT INFO/);

        $provides = $1      if (m/^\# provides:\s+(\S*.*\S+)\s*$/i);
        $requiredstart = $1 if (m/^\# required-start:\s+(\S*.*\S+)\s*$/i);
        $requiredstop = $1  if (m/^\# required-stop:\s+(\S*.*\S+)\s*$/i);
        $shouldstart = $1   if (m/^\# should-start:\s+(\S*.*\S+)\s*$/i);
        $shouldstop = $1    if (m/^\# should-stop:\s+(\S*.*\S+)\s*$/i);
        $startbefore = $1   if (m/^\# X-Start-Before:\s+(\S*.*\S+)\s*$/i);
        $stopafter = $1     if (m/^\# X-Stop-After:\s+(\S*.*\S+)\s*$/i);
    }
    close(FILE);

    return undef unless ($found);

#    print "Provides: $provides\n" if $provides;
    return {
            'provides'       => $provides,
            'required-start' => $requiredstart,
            'required-stop'  => $requiredstop,
            'should-start'   => $shouldstart,
            'should-stop'    => $shouldstop,
            'start-before'   => $startbefore,
            'stop-after'     => $stopafter,
            'file'           => $file,
            };
}
