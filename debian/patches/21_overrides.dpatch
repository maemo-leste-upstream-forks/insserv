#! /bin/sh /usr/share/dpatch/dpatch-run
## 20_overrides.dpatch by Petter Reinholdtsen <pere@hungry.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Implement support for reading LSB init.d header info from override
## DP: files.

@DPATCH@
diff -urNad insserv-1.09.0~/insserv.c insserv-1.09.0/insserv.c
--- insserv-1.09.0~/insserv.c	2007-12-31 12:03:35.734629003 -0200
+++ insserv-1.09.0/insserv.c	2007-12-31 12:04:21.573241198 -0200
@@ -23,6 +23,7 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/param.h>
 #include <dirent.h>
 #include <regex.h>
 #include <errno.h>
@@ -39,6 +40,9 @@
 #ifndef  INITDIR
 # define INITDIR	"/etc/init.d"
 #endif
+#ifndef  OVERRIDEDIR
+# define OVERRIDEDIR	"/etc/insserv/overrides"
+#endif
 #ifndef  INSCONF
 # define INSCONF	"/etc/insserv.conf"
 #endif
@@ -998,7 +1002,7 @@
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
 }
 
-static boolean scan_script_defaults(const char *const path)
+static boolean scan_lsb_headers(const char *const path)
 {
     regmatch_t subloc[SUBNUM_SHD+1], *val = &subloc[SUBNUM-1], *shl = &subloc[SUBNUM_SHD-1];
     FILE *script;
@@ -1022,18 +1026,6 @@
     if (!script)
 	error("fopen(%s): %s\n", path, strerror(errno));
 
-    /* Reset old results */
-    xreset(provides);
-    xreset(required_start);
-    xreset(required_stop);
-    xreset(should_start);
-    xreset(should_stop);
-    xreset(start_before);
-    xreset(stop_after);
-    xreset(default_start);
-    xreset(default_stop);
-    xreset(description);
-
 #define COMMON_ARGS	buf, SUBNUM, subloc, 0
 #define COMMON_SHD_ARGS	buf, SUBNUM_SHD, subloc, 0
     while (fgets(buf, sizeof(buf), script)) {
@@ -1169,10 +1161,113 @@
 #undef default_start
 #undef default_stop
 #undef description
+    return ret;
+}
 
+/*
+ * Follow symlinks, return the basename of the file pointed to by
+ * symlinks or the basename of the current path if no symlink.
+ */
+static char *scriptname(const char *path)
+{
+    struct stat st;
+    unsigned int deep = 0;
+    char linkbuf[PATH_MAX+1];
+    char *script = xstrdup(path);
+
+    strncpy(linkbuf, script, sizeof(linkbuf)-1);
+    linkbuf[PATH_MAX] = '\0';
+
+    do {
+        struct stat;
+	int linklen;
+
+	if (deep++ > MAXSYMLINKS) {
+	    errno = EMLINK;
+	    warn("Can not determine script name for %s: %s\n",
+		 path, strerror(errno));
+	    break;
+	}
+
+	if (lstat(script, &st) < 0) {
+	    warn("Can not stat %s: %s\n", script, strerror(errno));
+	    break;
+	}
+
+	if (!S_ISLNK(st.st_mode))
+	  break;
+
+	if ((linklen = readlink(script, linkbuf, sizeof(linkbuf)-1)) < 0)
+	    break;
+	linkbuf[linklen] = '\0';
+
+	free(script);
+	script = xstrdup(linkbuf);
+
+    } while (1);
+
+    free(script);
+    script = xstrdup(basename(linkbuf));
+
+    return script;
+}
+
+static boolean load_overrides(const char *const dir,
+			      const char *const name)
+{
+    boolean ret = 0;
+
+    char fullpath[PATH_MAX+1];
+    snprintf(fullpath, sizeof(fullpath), "%s/%s", dir, name);
+    struct stat statbuf;
+    if (0 == stat(fullpath, &statbuf) && S_ISREG(statbuf.st_mode)) {
+        ret = scan_lsb_headers(fullpath);
+    }
     return ret;
 }
 
+static boolean scan_script_defaults(const char *const path, const char *const override_path)
+{
+    boolean ret = 0;
+    boolean override = 0;
+    char *name = scriptname(path);
+
+    /* Reset old results */
+    xreset(script_inf.provides);
+    xreset(script_inf.required_start);
+    xreset(script_inf.required_stop);
+    xreset(script_inf.should_start);
+    xreset(script_inf.should_stop);
+    xreset(script_inf.start_before);
+    xreset(script_inf.stop_after);
+    xreset(script_inf.default_start);
+    xreset(script_inf.default_stop);
+    xreset(script_inf.description);
+
+    /* Load values if the override file exist */
+    override = load_overrides("/usr/share/insserv/overrides", name);
+
+    /* Replace with headers from the script itself */
+    ret = scan_lsb_headers(path);
+
+    /* Allow host-specific overrides to replace the content in the
+       init.d scripts */
+    override |= load_overrides(override_path, name);
+
+    if (!ret) {
+        warn("warning: script '%s' missing LSB tags\n", path);
+	if (!override) {
+	  warn("warning: script '%s' missing override too\n", name);
+	  script_inf.required_start = xstrdup("$remote_fs $syslog");
+	  script_inf.required_stop = xstrdup("$remote_fs $syslog");
+	  script_inf.default_start = xstrdup(DEFAULT_START_LVL);
+	  script_inf.default_stop = xstrdup(DEFAULT_STOP_LVL);
+	}
+    }
+    free(name);
+    return ret | override;
+}
+
 static inline void scan_script_regfree()
 {
     regfree(&reg.prov);
@@ -1237,7 +1332,7 @@
 /*
  * Scan current service structure
  */
-static void scan_script_locations(const char *const path)
+static void scan_script_locations(const char *const path, const char *const override_path)
 {
     int runlevel;
 
@@ -1274,7 +1369,7 @@
 		continue;
 	    }
 
-	    lsb = scan_script_defaults(d->d_name);
+	    lsb = scan_script_defaults(d->d_name, override_path);
 	    if (!script_inf.provides || script_inf.provides == empty)
 		script_inf.provides = xstrdup(ptr);
 
@@ -1561,6 +1656,7 @@
     {"remove",	0, NULL, 'r'},
     {"force",	0, NULL, 'f'},
     {"path",	1, NULL, 'p'},
+    {"override",1, NULL, 'o'},
     {"help",	0, NULL, 'h'},
     { 0,	0, NULL,  0 },
 };
@@ -1574,6 +1670,7 @@
     printf("  -f, --force      Ignore if a required service is missed.\n");
     printf("  -v, --verbose    Provide information on what is being done.\n");
     printf("  -p <path>, --path <path>  Path to replace " INITDIR ".\n");
+    printf("  -o <path>, --override <path> Path to replace " OVERRIDEDIR ".\n");
     printf("  -c <config>, --config <config>  Path to config file.\n");
     printf("  -n, --dryrun     Do not change the system, only talk about it.\n");
     printf("  -d, --default    Use default runlevels a defined in the scripts\n");
@@ -1590,6 +1687,7 @@
     struct stat st_script;
     char * argr[argc];
     char * path = INITDIR;
+    char * override_path = OVERRIDEDIR;
     char * insconf = INSCONF;
     int runlevel, c;
     boolean del = false;
@@ -1601,7 +1699,7 @@
     for (c = 0; c < argc; c++)
 	argr[c] = NULL;
 
-    while ((c = getopt_long(argc, argv, "c:dfrhvnp:", long_options, NULL)) != -1) {
+    while ((c = getopt_long(argc, argv, "c:dfrhvnp:o:", long_options, NULL)) != -1) {
 	switch (c) {
 	    case 'c':
 		insconf = optarg;
@@ -1625,6 +1723,9 @@
 	    case 'p':
 		path = optarg;
 		break;
+	    case 'o':
+		override_path = optarg;
+		break;
 	    case '?':
 		error("For help use: %s -h\n", myname);
 	    case 'h':
@@ -1736,7 +1837,7 @@
 #if 0
     if (!defaults)
 #endif
-    scan_script_locations(path);
+    scan_script_locations(path, override_path);
 
     if ((initdir = opendir(path)) == NULL)
 	error("can not opendir(%s): %s\n", path, strerror(errno));
@@ -1823,7 +1924,7 @@
 	}
 
 	/* main scanner for LSB comment in current script */
-	lsb = scan_script_defaults(d->d_name);
+	lsb = scan_script_defaults(d->d_name, override_path);
 
 	/* Common script ... */
 	if (!strcmp(d->d_name, "halt")) {
