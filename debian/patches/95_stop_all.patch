Patch from upstream making $all work for stop sequences, placing
scripts first in the stop sequence.  This patch invalidates
60_all_keyword_start_only.patch

Fixes #542043

Index: insserv/insserv.c
===================================================================
--- insserv.orig/insserv.c	2009-09-26 22:35:39.000000000 +0200
+++ insserv/insserv.c	2009-09-26 22:35:39.000000000 +0200
@@ -308,7 +308,10 @@
 	    break;
 	case '$':
 	    if (strcasecmp(token, "$all") == 0) {
-		serv->attr.flags |= SERV_ALL;
+		if (bit & REQ_KILL)
+		    serv->attr.flags |= SERV_FIRST;
+		else
+		    serv->attr.flags |= SERV_ALL;
 		break;
 	    }
 	    /* Expand the `$' token recursively down */
@@ -630,8 +633,7 @@
 }
 
 /*
- * Last but not least the `$all' scripts will be set to the
- * end of the current start order.
+ * The `$all' scripts will be set to the end of the current start order.
  */
 static inline void all_script(void) attribute((always_inline));
 static inline void all_script(void)
@@ -688,6 +690,50 @@
 }
 
 /*
+ * Last but not least the `$all' scripts will be set to the
+ * beginning of the current stop order.
+ */
+static inline void first_script(void) attribute((always_inline));
+static inline void first_script(void)
+{
+    list_t * pos;
+
+    list_for_each(pos, s_start) {
+	service_t * serv = getservice(pos);
+	list_t * tmp;
+
+	if (serv->attr.flags & SERV_DUPLET)
+	    continue;			/* Duplet */
+
+	if (!(serv->attr.flags & SERV_FIRST))
+	    continue;
+
+	if (serv->attr.script == (char*)0)
+	    continue;
+
+	list_for_each(tmp, s_start) {
+	    service_t * cur = getservice(tmp);
+
+	    if (cur->attr.flags & SERV_DUPLET)
+		continue;		/* Duplet */
+
+	    if ((serv->start->lvl & cur->start->lvl) == 0)
+		continue;
+
+	    if (cur == serv)
+		continue;
+
+	    if (cur->attr.flags & SERV_FIRST)
+		continue;
+
+	    rememberreq(serv, REQ_SHLD|REQ_KILL, cur->name);
+	}
+
+	setorder(serv->attr.script, 'K', 1, false);
+    }
+}
+
+/*
  * Make the dependency files
  */
 static inline void makedep(void) attribute((always_inline));
@@ -3274,6 +3320,11 @@
     nonlsb_script();
 
     /*
+     * Move the `$all' stop scripts to the very beginning
+     */
+    first_script();
+
+    /*
      * Now generate for all scripts the dependencies
      */
     follow_all();
Index: insserv/listing.c
===================================================================
--- insserv.orig/listing.c	2009-09-26 22:35:39.000000000 +0200
+++ insserv/listing.c	2009-09-26 22:35:39.000000000 +0200
@@ -317,6 +317,7 @@
     }
 
     for (tmp = dir; tmp; tmp = getnextlink(l_list)) {
+	const typeof(attof(tmp)->flags) sflags = attof(tmp)->flags;
 	register boolean recursion = true;
 	handle_t * ptmp = (mode == 'K') ? &tmp->stopp : &tmp->start;
 	uchar  * order = &ptmp->deep;
@@ -381,6 +382,7 @@
 	np_list_for_each(dent, l_list) {
 	    dir_t * target = getlink(dent)->target;
 	    handle_t * ptrg = (mode == 'K') ? &target->stopp : &target->start;
+	    const typeof(attof(target)->flags) kflags = attof(target)->flags;
 
 	    if ((peg->run.lvl & ptrg->run.lvl) == 0)
 		continue;			/* Not same boot level */
@@ -398,10 +400,18 @@
 		break;				/* Loop detected, stop recursion */
 	    }
 
-	    if ((mode == 'S') && (attof(tmp)->flags & SERV_ALL)) {
-		warn("%s depends on %s and therefore on system facility `$all' which can not be true!\n",
-		     target->script ? target->script : target->name, tmp->script ? tmp->script : tmp->name);
-		continue;
+	    if (mode == 'K') {
+		if (kflags & SERV_FIRST) {
+		    warn("Stopping %s depends on %s and therefore on system facility `$all' which can not be true!\n",
+			 tmp->script ? tmp->script : tmp->name, target->script ? target->script : target->name);
+		    continue;
+		}
+	    } else {
+		if (sflags & SERV_ALL) {
+		    warn("Starting %s depends on %s and therefore on system facility `$all' which can not be true!\n",
+			 target->script ? target->script : target->name, tmp->script ? tmp->script : tmp->name);
+		    continue;
+		}
 	    }
 
 	    if (ptrg->deep >= deep)		/* Nothing new */
@@ -847,7 +857,7 @@
     list_for_each(tmp, d_start) {
 	maxorder = &maxstart;
 	guess_order(getdir(tmp), 'S');
-	maxorder = &maxstart;
+	maxorder = &maxstop;
 	guess_order(getdir(tmp), 'K');
     }
 }
Index: insserv/listing.h
===================================================================
--- insserv.orig/listing.h	2009-09-26 22:35:39.000000000 +0200
+++ insserv/listing.h	2009-09-26 22:35:39.000000000 +0200
@@ -368,6 +368,7 @@
 #define SERV_SCRIPT	0x0080
 #define SERV_NOSTOP	0x0100
 #define SERV_CMDLINE	0x0200
+#define SERV_FIRST	0x0400
 
 /*
  * Bits of the runlevels
