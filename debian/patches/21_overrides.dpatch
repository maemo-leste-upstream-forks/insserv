#! /bin/sh /usr/share/dpatch/dpatch-run
## 21_overrides.dpatch by Petter Reinholdtsen <pere@hungry.com>
## Updated for insserv v1.10 by PEtter Reinholdtsen
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Implement support for reading LSB init.d header info from override
## DP: files.

@DPATCH@
diff -urNad insserv-1.10.0~/insserv.c insserv-1.10.0/insserv.c
--- insserv-1.10.0~/insserv.c	2008-01-07 17:37:09.000000000 +0100
+++ insserv-1.10.0/insserv.c	2008-01-07 17:40:25.000000000 +0100
@@ -25,6 +25,7 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/param.h>
 #include <dirent.h>
 #include <regex.h>
 #include <errno.h>
@@ -41,6 +42,9 @@
 #ifndef  INITDIR
 # define INITDIR	"/etc/init.d"
 #endif
+#ifndef  OVERRIDEDIR
+# define OVERRIDEDIR	"/etc/insserv/overrides"
+#endif
 #ifndef  INSCONF
 # define INSCONF	"/etc/insserv.conf"
 #endif
@@ -1047,7 +1051,21 @@
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
 }
 
-static boolean scan_script_defaults(const char *const path)
+static inline void scan_script_reset(void)
+{
+    xreset(script_inf.provides);
+    xreset(script_inf.required_start);
+    xreset(script_inf.required_stop);
+    xreset(script_inf.should_start);
+    xreset(script_inf.should_stop);
+    xreset(script_inf.start_before);
+    xreset(script_inf.stop_after);
+    xreset(script_inf.default_start);
+    xreset(script_inf.default_stop);
+    xreset(script_inf.description);
+}
+
+static boolean scan_lsb_headers(const char *const path)
 {
     regmatch_t subloc[SUBNUM_SHD+1], *val = &subloc[SUBNUM-1], *shl = &subloc[SUBNUM_SHD-1];
     FILE *script;
@@ -1071,25 +1089,18 @@
     if (!script)
 	error("fopen(%s): %s\n", path, strerror(errno));
 
-    /* Reset old results */
-    xreset(provides);
-    xreset(required_start);
-    xreset(required_stop);
-    xreset(should_start);
-    xreset(should_stop);
-    xreset(start_before);
-    xreset(stop_after);
-    xreset(default_start);
-    xreset(default_stop);
-    xreset(description);
-
 #define COMMON_ARGS	buf, SUBNUM, subloc, 0
 #define COMMON_SHD_ARGS	buf, SUBNUM_SHD, subloc, 0
     while (fgets(buf, sizeof(buf), script)) {
 
 	/* Skip scanning above from LSB magic start */
-	if (!begin && !(begin = strstr(buf, "### BEGIN INIT INFO")))
+	if (!begin) {
+	    if ( (begin = strstr(buf, "### BEGIN INIT INFO")) ) {
+	        /* Let the latest LSB header override the one found earlier */
+	        scan_script_reset();
+	    }
 	    continue;
+	}
 
 	if (!provides       && regexecutor(&reg.prov,      COMMON_ARGS) == true) {
 	    if (val->rm_so < val->rm_eo) {
@@ -1218,7 +1229,96 @@
 #undef default_start
 #undef default_stop
 #undef description
+    return ret;
+}
+
+/*
+ * Follow symlinks, return the basename of the file pointed to by
+ * symlinks or the basename of the current path if no symlink.
+ */
+static char *scriptname(const char *path)
+{
+    struct stat st;
+    unsigned int deep = 0;
+    char linkbuf[PATH_MAX+1];
+    char *script = xstrdup(path);
+
+    strncpy(linkbuf, script, sizeof(linkbuf)-1);
+    linkbuf[PATH_MAX] = '\0';
+
+    do {
+        struct stat;
+	int linklen;
+
+	if (deep++ > MAXSYMLINKS) {
+	    errno = EMLINK;
+	    warn("Can not determine script name for %s: %s\n",
+		 path, strerror(errno));
+	    break;
+	}
+
+	if (lstat(script, &st) < 0) {
+	    warn("Can not stat %s: %s\n", script, strerror(errno));
+	    break;
+	}
+
+	if (!S_ISLNK(st.st_mode))
+	  break;
+
+	if ((linklen = readlink(script, linkbuf, sizeof(linkbuf)-1)) < 0)
+	    break;
+	linkbuf[linklen] = '\0';
+
+	free(script);
+	script = xstrdup(linkbuf);
+
+    } while (1);
+
+    free(script);
+    script = xstrdup(basename(linkbuf));
+
+    return script;
+}
+
+static boolean load_overrides(const char *const dir,
+			      const char *const name)
+{
+    boolean ret = 0;
 
+    char fullpath[PATH_MAX+1];
+    snprintf(fullpath, sizeof(fullpath), "%s/%s", dir, name);
+    struct stat statbuf;
+    if (0 == stat(fullpath, &statbuf) && S_ISREG(statbuf.st_mode)) {
+        ret = scan_lsb_headers(fullpath);
+    }
+    return ret;
+}
+
+#define FOUND_LSB_HEADER   0x01
+#define FOUND_LSB_DEFAULT  0x02
+#define FOUND_LSB_OVERRIDE 0x02
+
+static boolean scan_script_defaults(const char *const path, const char *const override_path)
+{
+    int ret = 0;
+    char *name = scriptname(path);
+
+    /* Reset old results */
+    scan_script_reset();
+
+    /* Replace with headers from the script itself */
+    ret |= scan_lsb_headers(path);
+
+    if (!ret)
+	/* Load values if the override file exist */
+	ret |= load_overrides("/usr/share/insserv/overrides", name);
+
+
+    /* Allow host-specific overrides to replace the content in the
+       init.d scripts */
+    ret |= load_overrides(override_path, name);
+
+    free(name);
     return ret;
 }
 
@@ -1286,7 +1386,7 @@
 /*
  * Scan current service structure
  */
-static void scan_script_locations(const char *const path, char ** const iargv, const int icnt)
+static void scan_script_locations(const char *const path, const char *const override_path, char ** const iargv, const int icnt)
 {
     int runlevel;
 
@@ -1330,10 +1430,12 @@
 		continue;
 	    }
 
-	    lsb = scan_script_defaults(d->d_name);
+	    lsb = scan_script_defaults(d->d_name, override_path);
+
 	    if (!script_inf.provides || script_inf.provides == empty)
 		script_inf.provides = xstrdup(ptr);
 
+
 	    begin = script_inf.provides;
 	    while ((token = strsep(&begin, delimeter)) && *token) {
 		serv_t * service = (serv_t*)0;
@@ -1349,6 +1451,15 @@
 
 		if (!lsb)
 		    service->opts |= SERV_NOTLSB;
+		if (! (lsb & FOUND_LSB_HEADER) ) {
+		    if (! (lsb & (FOUND_LSB_DEFAULT | FOUND_LSB_OVERRIDE) ))
+		      warn("warning: script '%s' missing LSB tags and overrides\n",
+			   d->d_name);
+		    else
+  		        warn("warning: script '%s' missing LSB tags\n",
+			     d->d_name);
+		}
+
 		if (script_inf.required_start && script_inf.required_start != empty) {
 		    rememberreq(service, REQ_MUST, script_inf.required_start);
 		    requiresv(token, script_inf.required_start);
@@ -1433,16 +1544,7 @@
 	    }
 #endif /* not SUSE */
 
-	    xreset(script_inf.provides);
-	    xreset(script_inf.required_start);
-	    xreset(script_inf.required_stop);
-	    xreset(script_inf.should_start);
-	    xreset(script_inf.should_stop);
-	    xreset(script_inf.start_before);
-	    xreset(script_inf.stop_after);
-	    xreset(script_inf.default_start);
-	    xreset(script_inf.default_stop);
-	    xreset(script_inf.description);
+	    scan_script_reset();
 	}
 	popd();
 	closedir(rcdir);
@@ -1672,6 +1774,7 @@
     {"remove",	0, (int*)0, 'r'},
     {"force",	0, (int*)0, 'f'},
     {"path",	1, (int*)0, 'p'},
+    {"override",1, (int*)0, 'o'},
     {"help",	0, (int*)0, 'h'},
     { 0,	0, (int*)0,  0 },
 };
@@ -1685,6 +1788,7 @@
     printf("  -f, --force      Ignore if a required service is missed.\n");
     printf("  -v, --verbose    Provide information on what is being done.\n");
     printf("  -p <path>, --path <path>  Path to replace " INITDIR ".\n");
+    printf("  -o <path>, --override <path> Path to replace " OVERRIDEDIR ".\n");
     printf("  -c <config>, --config <config>  Path to config file.\n");
     printf("  -n, --dryrun     Do not change the system, only talk about it.\n");
     printf("  -d, --default    Use default runlevels a defined in the scripts\n");
@@ -1701,6 +1805,7 @@
     struct stat st_script;
     char * argr[argc];
     char * path = INITDIR;
+    char * override_path = OVERRIDEDIR;
     char * insconf = INSCONF;
     int runlevel, c;
     boolean del = false;
@@ -1712,7 +1817,7 @@
     for (c = 0; c < argc; c++)
 	argr[c] = (char*)0;
 
-    while ((c = getopt_long(argc, argv, "c:dfrhvnp:", long_options, (int *)0)) != -1) {
+    while ((c = getopt_long(argc, argv, "c:dfrhvno:p:", long_options, (int *)0)) != -1) {
 	switch (c) {
 	    case 'c':
 		insconf = optarg;
@@ -1736,6 +1841,9 @@
 	    case 'p':
 		path = optarg;
 		break;
+	    case 'o':
+		override_path = optarg;
+		break;
 	    case '?':
 		error("For help use: %s -h\n", myname);
 	    case 'h':
@@ -1858,7 +1966,7 @@
 #if 0
     if (!defaults)
 #endif
-    scan_script_locations(path, (del ? argv : (char**)0), argc);
+    scan_script_locations(path, override_path, (del ? argv : (char**)0), argc);
 
     if ((initdir = opendir(path)) == (DIR*)0)
 	error("can not opendir(%s): %s\n", path, strerror(errno));
@@ -1945,7 +2053,16 @@
 	}
 
 	/* main scanner for LSB comment in current script */
-	lsb = scan_script_defaults(d->d_name);
+	lsb = scan_script_defaults(d->d_name, override_path);
+
+	if (! (lsb & FOUND_LSB_HEADER) ) {
+	    if (! (lsb & (FOUND_LSB_DEFAULT | FOUND_LSB_OVERRIDE) ))
+	        warn("warning: script '%s' missing LSB tags and overrides\n",
+		     d->d_name);
+	    else
+	        warn("warning: script '%s' missing LSB tags\n",
+		     d->d_name);
+	}
 
 	/* Common script ... */
 	if (!strcmp(d->d_name, "halt")) {
@@ -2297,16 +2414,7 @@
 	    service->opts |= SERV_NOTLSB;
     }
     /* Reset remaining pointers */
-    xreset(script_inf.provides);
-    xreset(script_inf.required_start);
-    xreset(script_inf.required_stop);
-    xreset(script_inf.should_start);
-    xreset(script_inf.should_stop);
-    xreset(script_inf.start_before);
-    xreset(script_inf.stop_after);
-    xreset(script_inf.default_start);
-    xreset(script_inf.default_stop);
-    xreset(script_inf.description);
+    scan_script_reset();
 
     /*
      * Free the regular scanner for the scripts.
