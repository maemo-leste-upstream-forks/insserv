#! /bin/sh /usr/share/dpatch/dpatch-run
## 50_symlink_in_initddir.patch by Kel Modderman <kel@otaku42.de>
##
## DP: Purpose: Defend against symlinks in init.d/ to other scripts in init.d/
## DP: Fixes:   #485045
## DP: Status:  Work in progress.

@DPATCH@
--- a/insserv.c
+++ b/insserv.c
@@ -2542,11 +2542,12 @@
 	errno = 0;
 
 	/* d_type seems not to work, therefore use (l)stat(2) */
-	if (xstat(dfd, d->d_name, &st_script) < 0) {
+	if (xlstat(dfd, d->d_name, &st_script) < 0) {
 	    warn("can not stat(%s)\n", d->d_name);
 	    continue;
 	}
-	if (!S_ISREG(st_script.st_mode) || !(S_IXUSR & st_script.st_mode))
+	if ((!S_ISLNK(st_script.st_mode) && !S_ISREG(st_script.st_mode)) ||
+	    !(S_IXUSR & st_script.st_mode))
 	{
 	    if (S_ISDIR(st_script.st_mode))
 		continue;
@@ -2555,6 +2556,43 @@
 	    continue;
 	}
 
+	/*
+	 * Do extra sanity checking of symlinks in init.d/ dir, except if it
+	 * is named reboot, as that is a special case on SUSE
+	 */
+	if (S_ISLNK(st_script.st_mode) && ((strcmp(d->d_name, "reboot") != 0)))
+	{
+	    char * base;
+	    char linkbuf[PATH_MAX+1];
+	    int  linklen;
+
+	    linklen = xreadlink(dfd, d->d_name, linkbuf, sizeof(linkbuf)-1);
+	    if (linklen < 0)
+		continue;
+	    linkbuf[linklen] = '\0';
+
+	    /* skip symbolic links to other scripts in this relative path */
+	    if (!(base = strrchr(linkbuf, '/'))) {
+		if (isarg)
+		    warn("script %s is a symlink to another script, skipped!\n",
+			 d->d_name);
+		continue;
+	    }
+
+	    /* stat the symlink target and make sure it is a valid script */
+	    if (xstat(dfd, d->d_name, &st_script) < 0)
+		continue;
+
+	    if (!S_ISREG(st_script.st_mode) || !(S_IXUSR & st_script.st_mode)) {
+	        if (S_ISDIR(st_script.st_mode))
+		    continue;
+		if (isarg)
+		    warn("script %s is not an executable regular file, skipped!\n",
+			 d->d_name);
+		continue;
+	    }
+	}
+
 	if (!strncmp(d->d_name, "README", strlen("README"))) {
 	    if (isarg)
 		warn("script name %s is not valid, skipped!\n", d->d_name);
