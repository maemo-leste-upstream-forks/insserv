#!/usr/bin/perl
#
# Author: Petter Reinholdtsen
# Date:   2005-08-21
#
# Read LSM init.d headers in SysV init.d scripts, and verify correct
# start order for all runlevels.  It can also provide a graph.
#
# To generate a graph, run it like this
#
#   check-initd-order -g > initorder.dotty && dotty initorder.dotty

use strict;
use warnings;

my $rcbase = "/etc";
#$rcbase = "/opt/ltsp/i386/etc";

my $overridepath = "/usr/share/insserv/overrides";
my $hostoverridepath =  "/etc/insserv/overrides";

my $debug = 0;

my %rcmap =
    (
     'B' => 'rc.boot',
     'S' => 'rcS.d',
     '1' => 'rc1.d',
     '2' => 'rc2.d',
     '3' => 'rc3.d',
     '4' => 'rc4.d',
     '5' => 'rc5.d',
     '6' => 'rc6.d',
     );

# Map packages to system metapackages.  These dependencies should
# probably be more complex
my %sysmap =
    (
     'network'      => '$network',
     'networking'   => '$network',
     'syslog'       => '$syslog',
     'sysklogd'     => '$syslog',
     'mountall'     => '$local_fs',
     'umountfs'     => '$local_fs',
     'mountnfs'     => '$remote_fs',
     'mountnfs-bootclean' => '$remote_fs',
     'umountnfs'    => '$remote_fs',
     'sendsigs'     => '$remote_fs',
     'hwclock'      => '$time',
     'ntpdate'      => '$time',
     'ntp-server'   => '$time',
     'named'        => '$named',
     'dnsmasq'      => '$named',
     'lwresd'       => '$named',
     'bind9'        => '$named',
     'portmap'      => '$portmap',
     );

my %provideslist;
my %scriptorder;
my %opts;

my %graphnodes = ();
my %graphlinks = ();

while($#ARGV >= 0 && ($_ = $ARGV[0]) =~ /^-/) {
        shift @ARGV;
        if (/^-([cdgko])$/) { $opts{$1}++; next }
        if (/^-h|--help$/) { &usage; }
        &usage("unknown option");
}

$debug = $opts{'d'};
my $useoverrides = $opts{'o'} ? 0 : 1;

if ($opts{'g'}) {
    graph_generate();
    exit 0;
}

check_bootorder();

sub usage {
    print STDERR "check-initd-order: error: @_\n" if ($#_ >= 0);
    print STDERR <<EOF;
usage: check-initd-order [-dgko]
EOF
    exit 1;
}

# Simple basename implementatin to avoid dependin on File::Basename
# from perl-modules
sub basename {
    my $path = shift;
    $path =~ s%^.*/([^/]+)$%$1%;
    return $path;
}

sub graph_add_link {
    my ($from, $to, $color) = @_;
    print "\"$from\" -> \"$to\"[color=$color] ;\n"
        unless exists $graphlinks{"$from/$to"};
    $graphlinks{"$from/$to"} = 1;
}

sub graph_addnode {
    my ($key, $lsbinforef) = @_;
    my %lsbinfo = %{$lsbinforef};

    unless ($lsbinfo{'provides'}) {
        print STDERR "error: File ". $lsbinfo{'file'} . " is missing the provides header\n";
        $lsbinfo{'provides'} = $lsbinfo{'file'};
    }

    my $keystr = 'S' eq $key ? 'start' : 'stop';
    my $revkey = 'S' eq $key ? 'start-before' : 'stop-after';
    my @provides = split(/\s+/, $lsbinfo{'provides'});
    for my $name (@provides) {
        if (exists $sysmap{$name}) {
            graph_addnode($key,
                          {'provides'         => $sysmap{$name},
                           "required-$keystr" => $name});
        }
    }

    if (1 < @provides) {
        print STDERR "warning: Unable to properly graph multiple provides: @provides\n";
    }

    my %deps =
        (
         "required-$keystr" => 'blue',
         "should-$keystr"   => 'springgreen',
         "$revkey"          => 'yellow'
         );

    for my $header (keys %deps) {
        print STDERR "Checking $provides[0] for $header\n";
        if (exists $lsbinfo{$header} && $lsbinfo{$header}) {
            my @depends = split(/\s+/, $lsbinfo{$header});
            for my $pkg (@depends) {
                print STDERR "  Found $pkg\n";
                my $color = $deps{$header};
                if ($revkey eq $header) {
                    graph_add_link($provides[0], $pkg, $color);
                } else {
                    graph_add_link($pkg, $provides[0], $color);
                }
            }
        }
    }

    print "\"$provides[0]\" [shape=box];\n" unless
        exists $graphnodes{$provides[0]};
    $graphnodes{$provides[0]} = 1;
}

sub graph_generate {
    print "# Generating graph\n";
    print <<EOF;
digraph packages {
rankdir=LR;
concentrate=true;
EOF
    my @keys;
    my @dirs;
    my $glob;
    if ($opts{'k'}) {
        @dirs =  $rcmap{6};
        push(@keys, "K", "S");
    } elsif ($opts{'c'}) {
        @dirs =($rcmap{S}, $rcmap{2}, $rcmap{6});
        push(@keys, "K", "S");
    } else {
        @dirs =($rcmap{S}, $rcmap{2});
        push(@keys, "S");
    }
    for my $rcdir (@dirs) {
        chdir "$rcbase/$rcdir/.";
        for my $key (@keys) {
            my @scripts = <$key*>;
            for my $script (@scripts) {
                print STDERR "Loading $script\n";
                my $lsbinforef = load_lsb_tags("$rcbase/$rcdir/$script",
                                               $useoverrides);

                unless (defined $lsbinforef) {
                    print STDERR "warning: LSB header missing in $rcbase/$rcdir/$script\n";
                    $lsbinforef = {'provides'       => $script,
                                   'required-start' => '$remote_fs $syslog',
                                   'required-stop'  => '$remote_fs $syslog'};
                }
                graph_addnode($key, $lsbinforef);
            }
        }
    }
    print <<EOF;
}
EOF
}

sub check_deps {
    my ($lsbinforef, $tag, $order, $bootorder, $headername, $required) = @_;
    my %lsbinfo = %{$lsbinforef};
    my $name = $lsbinfo{'file'};
    if ($lsbinfo{$headername}) {
        my @depends = split(/\s+/, $lsbinfo{$headername});
        for my $dep (@depends) {
            if (! $required && exists $provideslist{$dep}) {
                unless (exists $scriptorder{$tag}{$dep}
                        and ("S" eq $tag
                             ? $scriptorder{$tag}{$dep} < $bootorder
                             : $scriptorder{$tag}{$dep} > $bootorder)) {
                    my $deporder;
                    if (exists $scriptorder{$tag}{$dep}) {
                        $deporder = $scriptorder{$tag}{$dep}
                    } else {
                        $deporder = exists $provideslist{$dep} ? $provideslist{$dep} : "?";
                    }
                    printf("Incorrect order %s@%s %s %s%s\n",
                           $dep, $deporder, 'S' eq $tag ? '>' : '<',
                           $name, $order);
                }
            }
        }
    }
}

sub check_bootorder {
    my $bootorder = 0;
    my @dirs = $opts{'k'} ? $rcmap{6} : ($rcmap{S}, $rcmap{2});
    my @scripts;
    for my $rcdir (@dirs) {
#        chdir "$rcbase/$rcdir/.";
        push(@scripts, $opts{'k'} ? <$rcbase/$rcdir/K*> : <$rcbase/$rcdir/S*>);
    }

    if ($opts{'k'}) {
        $scriptorder{'K'}{'$all'} = 1;
    } else {
        # Calculate script order for the script before the scripts
        # with the last boot sequence number.
        my $tmpbootorder = 0;
        my $allorder = 0;
        my $maxorder = 0;
        my $maxbootorder = 0;
        for my $scriptpath (@scripts) {
            my $script = $scriptpath;
            $script =~ s%^.*/([^/]+)$%$1%;
            $tmpbootorder++;
            my ($tag, $order, $name) = $script =~ m/^(.)(\d{2})(.+)$/;
            if ($order > $maxorder) {
                $allorder = $maxbootorder;
                $maxbootorder = $tmpbootorder;
                $maxorder = $order;
            }

            my $lsbinforef = load_lsb_tags($scriptpath,
                                           $useoverrides);

            if (exists $lsbinforef->{'provides'}) {
                for my $provide (split(/\s+/, $lsbinforef->{'provides'})) {
                    $provideslist{$provide} = $order;
                }
            } else {
                $provideslist{$script} = $order;
            }
        }
        $scriptorder{'S'}{'$all'} = $allorder;
    }
    for my $scriptpath (@scripts) {
        my $script = $scriptpath;
        $script =~ s%^.*/([^/]+)$%$1%;
        $bootorder++;
        my ($tag, $order, $name) = $script =~ m/^(.)(\d{2})(.+)$/;

        $scriptorder{$tag}{$name} = $bootorder;
        $scriptorder{$tag}{$sysmap{$name}} = $bootorder
            if (exists $sysmap{$name});

#           print "$script\n";
#           print "T: $tag O: $order N: $name\n";
        my $lsbinforef = load_lsb_tags($scriptpath,
                                       $useoverrides);

        unless (defined $lsbinforef) {
            print STDERR "LSB header missing in $scriptpath\n";
            next;
        }
        my %lsbinfo = %{$lsbinforef};

        for my $provide (split(/\s+/, $lsbinfo{'provides'})) {
            $scriptorder{$tag}{$provide} = $bootorder;
            $scriptorder{$tag}{$sysmap{$provide}} = $bootorder
                if (exists $sysmap{$provide});
        }

        if ('S' eq $tag) {
            check_deps($lsbinforef, $tag, $order, $bootorder, 'required-start', 1);
            check_deps($lsbinforef, $tag, $order, $bootorder, 'should-start', 0);
            check_deps($lsbinforef, 'K', $order, $bootorder, 'start-before', 0);
        }
        if ('K' eq $tag) {
            check_deps($lsbinforef, $tag, $order, $bootorder, 'required-stop', 1);
            check_deps($lsbinforef, $tag, $order, $bootorder, 'should-stop', 0);
            check_deps($lsbinforef, 'S', $order, $bootorder, 'stop-after', 0);
        }
    }
}

sub load_lsb_tags {
    my ($initfile, $useoverrides) = @_;
    my $lsbinforef = load_lsb_tags_from_file($initfile);

    if ($useoverrides) {
        # Try override file
        $initfile = readlink($initfile) if (-l $initfile);
        my $basename = basename($initfile);

        # Only read shipped override file when initscript does not
        # contain LSB tags.
        if (! defined($lsbinforef) && -f "$overridepath/$basename") {
            print STDERR "Override $overridepath/$basename\n" if $debug;
            $lsbinforef = load_lsb_tags_from_file("$overridepath/$basename");
        }

        # Always read the host override in $hostoverridepath.
        if (-f "$hostoverridepath/$basename") {
            print STDERR "Override $hostoverridepath/$basename\n" if $debug;
            $lsbinforef = load_lsb_tags_from_file("$hostoverridepath/$basename");
        }

    }
    return $lsbinforef;
}

sub load_lsb_tags_from_file {
    my ($file) = @_;
    print STDERR "Loading $file\n" if $debug;
    ### BEGIN INIT INFO
    # Provides:          xdebconfigurator
    # Required-Start:    $syslog
    # Required-Stop:     $syslog
    # Default-Start:     2 3 4 5
    # Default-Stop:      1 6
    # Short-Description: Genererate xfree86 configuration at boot time
    # Description:       Preseed X configuration and use dexconf to
    #                    genereate a new configuration file.
    ### END INIT INFO
    unless (open(FILE, "<$file")) {
        warn "error: Unable to read $file";
        return;
    }
    my $found = 0;
    my ($provides, $requiredstart, $requiredstop, $shouldstart, $shouldstop);
    my ($startbefore, $stopafter);
    while (<FILE>) {
        chomp;
        $found = 1 if (m/\#\#\# BEGIN INIT INFO/);
        next unless $found;
        last if (m/\#\#\# END INIT INFO/);

        $provides = $1      if (m/^\# provides:\s+(\S*.*\S+)\s*$/i);
        $requiredstart = $1 if (m/^\# required-start:\s+(\S*.*\S+)\s*$/i);
        $requiredstop = $1  if (m/^\# required-stop:\s+(\S*.*\S+)\s*$/i);
        $shouldstart = $1   if (m/^\# should-start:\s+(\S*.*\S+)\s*$/i);
        $shouldstop = $1    if (m/^\# should-stop:\s+(\S*.*\S+)\s*$/i);
        $startbefore = $1   if (m/^\# X-Start-Before:\s+(\S*.*\S+)\s*$/i);
        $stopafter = $1     if (m/^\# X-Stop-After:\s+(\S*.*\S+)\s*$/i);
    }
    close(FILE);

    return undef unless ($found);

#    print "Provides: $provides\n" if $provides;
    return {
            'provides'       => $provides,
            'required-start' => $requiredstart,
            'required-stop'  => $requiredstop,
            'should-start'   => $shouldstart,
            'should-stop'    => $shouldstop,
            'start-before'   => $startbefore,
            'stop-after'     => $stopafter,
            'file'           => $file,
            };
}
