Purpose: Add support for upstart jobs.
Fixes:   #547235
Status:  Work in progress, not submitted upstream yet.
---

Index: insserv/insserv.8.in
===================================================================
--- insserv.orig/insserv.8.in	2009-09-26 22:35:39.000000000 +0200
+++ insserv/insserv.8.in	2009-09-26 22:35:42.000000000 +0200
@@ -266,6 +266,10 @@
 .BR \-f ,\  \-\-force
 Ignore if a required service is missed.
 .TP
+.BR \-u\ <path> ,\  \-\-upstart-job\ <path>
+Path to replace existing upstart job path.  (default path is
+.IR /lib/init/upstart-job ).
+.TP
 .BR \-h ,\  \-\-help
 Print out short usage message.
 .PP
@@ -339,6 +343,12 @@
 name as the boot or init script in the directory
 .IR /etc/insserv/overrides/ .
 .\"
+.SH UPSTART JOB COMPATIBILITY
+To allow upstart jobs to work as init.d scripts, insserv will
+recognize a symlink from path/to/init.d/script to
+/lib/init/upstart-job as upstart jobs, and instead of reading the
+header from the file will run the script with the argument lsb-header
+to get the script header.
 .SH EXIT CODES
 The exit codes have the following conditions:
 .RS 7
Index: insserv/insserv.c
===================================================================
--- insserv.orig/insserv.c	2009-09-26 22:35:39.000000000 +0200
+++ insserv/insserv.c	2009-09-26 22:35:43.000000000 +0200
@@ -70,6 +70,8 @@
 # define INSCONF	"/etc/insserv.conf"
 #endif
 
+const char *upstartjob_path = "/lib/init/upstart-job";
+
 /*
  * For a description of regular expressions see regex(7).
  */
@@ -1154,6 +1156,43 @@
     xreset(script_inf.interactive);
 }
 
+static char *is_upstart_job_recursive(const char *path,
+				      const char *basenamestr)
+{
+    struct stat statbuf;
+    if (-1 == lstat(path, &statbuf)) {
+	return 0;
+    }
+    if (S_ISLNK(statbuf.st_mode)) {
+        char buf[2048];
+        int len = readlink(path, buf, sizeof(buf)-1);
+	if (0 < len) {
+	    buf[len] = '\0';
+	    if (0 == strcmp(buf, upstartjob_path)) {
+	      /* upstart job, return base name of original symlink */
+	      return strdup(basenamestr);
+	    } else
+	      return is_upstart_job_recursive(buf, basenamestr);
+	}
+    }
+    return 0;
+}
+
+/*
+ * return name of upstart job if the script is a symlink to
+ * /lib/init/upstart-job, or NULL if path do not point to an
+ * upstart job.
+ */
+static char* is_upstart_job(const char *path)
+{
+
+    char *basenamestr = basename(path); /* GNU basename */
+    char *retval = is_upstart_job_recursive(path, basenamestr);
+    if (retval)
+        info("script '%s' is upstart job\n", basenamestr);
+    return retval;
+}
+
 #define FOUND_LSB_HEADER   0x01
 #define FOUND_LSB_DEFAULT  0x02
 #define FOUND_LSB_OVERRIDE 0x04
@@ -1170,7 +1209,8 @@
     char *pbuf = buf;
     FILE *script;
     uchar ret = 0;
-    int fd;
+    int fd = -1;
+    char *upstart_job = NULL;
 
 #define provides	script_inf.provides
 #define required_start	script_inf.required_start
@@ -1186,12 +1226,23 @@
 
     info("Loading %s\n", path);
 
-    if ((fd = xopen(dfd, path, o_flags)) < 0 || (script = fdopen(fd, "r")) == (FILE*)0)
-	error("fopen(%s): %s\n", path, strerror(errno));
+    if (NULL != (upstart_job = is_upstart_job(path))) {
+        char cmd[2048];
+	int len;
+	len = snprintf(cmd, sizeof(cmd),
+		       "%s %s lsb-header", upstartjob_path, upstart_job);
+	if (len < 0 || sizeof(cmd) == len)
+	    error("snprintf: insufficient buffer for %s\n", path);
+	if ((FILE*)0 == (script = popen(cmd, "r")))
+	    error("popen(%s): %s\n", path, strerror(errno));
+    } else {
+        if ((fd = xopen(dfd, path, o_flags)) < 0 || (script = fdopen(fd, "r")) == (FILE*)0)
+	    error("fopen(%s): %s\n", path, strerror(errno));
 
 #if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) >= 600
-    (void)posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
+	(void)posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
 #endif
+    }
 
 #define COMMON_ARGS	buf, SUBNUM, subloc, 0
 #define COMMON_SHD_ARGS	buf, SUBNUM_SHD, subloc, 0
@@ -1303,7 +1354,12 @@
 	(void)posix_fadvise(fd, 0, 0, POSIX_FADV_NOREUSE);
 #endif
 
-    fclose(script);
+    if (upstart_job) {
+        pclose(script);
+        free(upstart_job);
+        upstart_job = 0;
+    } else
+        fclose(script);
 
     if (begin && end)
 	ret |= FOUND_LSB_HEADER;
@@ -2224,6 +2280,7 @@
     {"force",	0, (int*)0, 'f'},
     {"path",	1, (int*)0, 'p'},
     {"override",1, (int*)0, 'o'},
+    {"upstart-job",1, (int*)0, 'u'},
     {"help",	0, (int*)0, 'h'},
     { 0,	0, (int*)0,  0 },
 };
@@ -2277,7 +2334,7 @@
     for (c = 0; c < argc; c++)
 	argr[c] = (char*)0;
 
-    while ((c = getopt_long(argc, argv, "c:dfrhvno:p:", long_options, (int *)0)) != -1) {
+    while ((c = getopt_long(argc, argv, "c:dfrhvno:p:u:", long_options, (int *)0)) != -1) {
 	size_t l;
 	switch (c) {
 	    case 'c':
@@ -2317,6 +2374,11 @@
 		override_path = optarg;
 		set_override = true;
 		break;
+	    case 'u':
+		if (optarg == (char*)0 || *optarg == '\0')
+		    goto err;
+		upstartjob_path = optarg;
+		break;
 	    case '?':
 	    err:
 		error("For help use: %s -h\n", myname);
