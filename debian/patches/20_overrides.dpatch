#! /bin/sh /usr/share/dpatch/dpatch-run
## 20_overrides.dpatch by Petter Reinholdtsen <pere@hungry.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Implement support for reading LSB init.d header info from override
## DP: files.

@DPATCH@
--- insserv-1.08.0/insserv.c	2006-02-06 16:45:54.000000000 +0100
+++ insserv/insserv.c	2006-09-07 00:38:06.000000000 +0200
@@ -23,6 +23,7 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/param.h>
 #include <dirent.h>
 #include <regex.h>
 #include <errno.h>
@@ -945,7 +946,7 @@
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
 }
 
-static boolean scan_script_defaults(const char *const path)
+static boolean scan_lsb_headers(const char *const path)
 {
     regmatch_t subloc[SUBNUM_SHD+1], *val = &subloc[SUBNUM-1], *shl = &subloc[SUBNUM_SHD-1];
     FILE *script;
@@ -967,16 +968,6 @@
     if (!script)
 	error("fopen(%s): %s\n", path, strerror(errno));
 
-    /* Reset old results */
-    xreset(provides);
-    xreset(required_start);
-    xreset(required_stop);
-    xreset(should_start);
-    xreset(should_stop);
-    xreset(default_start);
-    xreset(default_stop);
-    xreset(description);
-
 #define COMMON_ARGS	buf, SUBNUM, subloc, 0
 #define COMMON_SHD_ARGS	buf, SUBNUM_SHD, subloc, 0
     while (fgets(buf, sizeof(buf), script)) {
@@ -1094,10 +1085,111 @@
 #undef default_start
 #undef default_stop
 #undef description
+    return ret;
+}
+
+/*
+ * Follow symlinks, return the basename of the file pointed to by
+ * symlinks or the basename of the current path if no symlink.
+ */
+static char *scriptname(const char *path)
+{
+    struct stat st;
+    unsigned int deep = 0;
+    char linkbuf[PATH_MAX+1];
+    char *script = xstrdup(path);
+
+    strncpy(linkbuf, script, sizeof(linkbuf)-1);
+    linkbuf[PATH_MAX] = '\0';
+
+    do {
+        struct stat;
+	int linklen;
+
+	if (deep++ > MAXSYMLINKS) {
+	    errno = EMLINK;
+	    warn("Can not determine script name for %s: %s\n",
+		 path, strerror(errno));
+	    break;
+	}
+
+	if (lstat(script, &st) < 0) {
+	    warn("Can not stat %s: %s\n", script, strerror(errno));
+	    break;
+	}
+
+	if (!S_ISLNK(st.st_mode))
+	  break;
+
+	if ((linklen = readlink(script, linkbuf, sizeof(linkbuf)-1)) < 0)
+	    break;
+	linkbuf[linklen] = '\0';
+
+	free(script);
+	script = xstrdup(linkbuf);
+
+    } while (1);
+
+    free(script);
+    script = xstrdup(basename(linkbuf));
 
+    return script;
+}
+
+static boolean load_overrides(const char *const dir,
+			      const char *const name)
+{
+    boolean ret = 0;
+
+    char fullpath[PATH_MAX+1];
+    snprintf(fullpath, sizeof(fullpath), "%s/%s", dir, name);
+    struct stat statbuf;
+    if (0 == stat(fullpath, &statbuf) && S_ISREG(statbuf.st_mode)) {
+        ret = scan_lsb_headers(fullpath);
+    }
     return ret;
 }
 
+static boolean scan_script_defaults(const char *const path)
+{
+    boolean ret = 0;
+    boolean override = 0;
+    char *name = scriptname(path);
+
+    /* Reset old results */
+    xreset(script_inf.provides);
+    xreset(script_inf.required_start);
+    xreset(script_inf.required_stop);
+    xreset(script_inf.should_start);
+    xreset(script_inf.should_stop);
+    xreset(script_inf.default_start);
+    xreset(script_inf.default_stop);
+    xreset(script_inf.description);
+
+    /* Load values if the override file exist */
+    override = load_overrides("/usr/share/insserv/overrides", name);
+
+    /* Replace with headers from the script itself */
+    ret = scan_lsb_headers(path);
+
+    /* Allow host-specific overrides to replace the content in the
+       init.d scripts */
+    override |= load_overrides("/etc/insserv/overrides", name);
+
+    if (!ret) {
+        warn("warning: script '%s' missing LSB tags\n", path);
+	if (!override) {
+	  warn("warning: script '%s' missing override too\n", name);
+	  script_inf.required_start = xstrdup("$remote_fs $syslog");
+	  script_inf.required_stop = xstrdup("$remote_fs $syslog");
+	  script_inf.default_start = xstrdup(DEFAULT_START_LVL);
+	  script_inf.default_stop = xstrdup(DEFAULT_STOP_LVL);
+	}
+    }
+    free(name);
+    return ret | override;
+}
+
 static inline void scan_script_regfree()
 {
     regfree(&reg.prov);
