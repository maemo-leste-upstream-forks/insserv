#! /bin/sh /usr/share/dpatch/dpatch-run
## 42_redundantlvl.dpatch by Petter Reinholdtsen <pere@hungry.com>

Rewrite most locations with hardcoded information about levels to use
the runlevel_locations array to fetch the information instead.  This
reduces the redundancy and make it easier to keep the level settings
in sync across the code.

The runlevel_locations array is extended to include the runlevel kode
in it.

@DPATCH@
--- insserv-1.09.0~/insserv.c	2008-01-04 11:22:09.000000000 +0100
+++ insserv-1.09.0/insserv.c	2008-01-04 11:22:09.000000000 +0100
@@ -32,8 +32,8 @@
 #include "listing.h"
 
 static const char *map_runlevel_to_location(const int runlevel);
+const int map_runlevel_to_lvl (const int runlevel);
 #ifndef SUSE
-static const int map_runlevel_to_lvl (const int runlevel);
 static const int map_runlevel_to_seek(const int runlevel);
 #endif /* not SUSE */
 
@@ -471,22 +471,7 @@
     if (serv->order < order)
 	serv->order = order;
 
-    switch (runlvl) {
-	case 0: serv->lvls |= LVL_HALT;   break;
-	case 1: serv->lvls |= LVL_ONE;    break;
-	case 2: serv->lvls |= LVL_TWO;    break;
-	case 3: serv->lvls |= LVL_THREE;  break;
-	case 4: serv->lvls |= LVL_FOUR;   break;
-	case 5: serv->lvls |= LVL_FIVE;   break;
-	case 6: serv->lvls |= LVL_REBOOT; break;
-#ifdef SUSE
-	case 7: serv->lvls |= LVL_SINGLE; break;
-	case 8: serv->lvls |= LVL_BOOT;   break;
-#else  /* not SUSE */
-	case 7: serv->lvls |= LVL_BOOT;   break;
-#endif /* not SUSE */
-	default: break;
-    }
+    serv->lvls |= map_runlevel_to_lvl(runlvl);
 
     return serv;
 }
@@ -1304,45 +1289,82 @@
     char *location;
     const int lvl;
     const int seek;
+    char key;
 } runlevel_locations[] = {
 #ifdef SUSE	/* SuSE's SystemV link scheme */
-    {"rc0.d/",    LVL_HALT,   LVL_NORM},
-    {"rc1.d/",    LVL_ONE,    LVL_NORM}, /* runlevel 1 switch over to single user mode */
-    {"rc2.d/",    LVL_TWO,    LVL_NORM},
-    {"rc3.d/",    LVL_THREE,  LVL_NORM},
-    {"rc4.d/",    LVL_FOUR,   LVL_NORM},
-    {"rc5.d/",    LVL_FIVE,   LVL_NORM},
-    {"rc6.d/",    LVL_REBOOT, LVL_NORM},
-    {"rcS.d/",    LVL_SINGLE, LVL_NORM}, /* runlevel S is for single user mode */
-    {"boot.d/",   LVL_BOOT,   LVL_BOOT}, /* runlevel B is for system initialization */
+    {"rc0.d/",    LVL_HALT,   LVL_NORM, '0'},
+    {"rc1.d/",    LVL_ONE,    LVL_NORM, '1'}, /* runlevel 1 switch over to single user mode */
+    {"rc2.d/",    LVL_TWO,    LVL_NORM, '2'},
+    {"rc3.d/",    LVL_THREE,  LVL_NORM, '3'},
+    {"rc4.d/",    LVL_FOUR,   LVL_NORM, '4'},
+    {"rc5.d/",    LVL_FIVE,   LVL_NORM, '5'},
+    {"rc6.d/",    LVL_REBOOT, LVL_NORM, '6'},
+    {"rcS.d/",    LVL_SINGLE, LVL_NORM, 'S'}, /* runlevel S is for single user mode */
+    {"boot.d/",   LVL_BOOT,   LVL_BOOT, 'B'}, /* runlevel B is for system initialization */
 #else		/* not SUSE (actually, Debian) */
-    {"../rc0.d/", LVL_HALT,   LVL_NORM},
-    {"../rc1.d/", LVL_ONE,    LVL_NORM}, /* runlevel 1 switch over to single user mode */
-    {"../rc2.d/", LVL_TWO,    LVL_NORM},
-    {"../rc3.d/", LVL_THREE,  LVL_NORM},
-    {"../rc4.d/", LVL_FOUR,   LVL_NORM},
-    {"../rc5.d/", LVL_FIVE,   LVL_NORM},
-    {"../rc6.d/", LVL_REBOOT, LVL_NORM},
-    {"../rcS.d/", LVL_BOOT,   LVL_BOOT}, /* runlevel S is for system initialization */
+    {"../rc0.d/", LVL_HALT,   LVL_NORM, '0'},
+    {"../rc1.d/", LVL_ONE,    LVL_NORM, '1'}, /* runlevel 1 switch over to single user mode */
+    {"../rc2.d/", LVL_TWO,    LVL_NORM, '2'},
+    {"../rc3.d/", LVL_THREE,  LVL_NORM, '3'},
+    {"../rc4.d/", LVL_FOUR,   LVL_NORM, '4'},
+    {"../rc5.d/", LVL_FIVE,   LVL_NORM, '5'},
+    {"../rc6.d/", LVL_REBOOT, LVL_NORM, '6'},
+    {"../rcS.d/", LVL_BOOT,   LVL_BOOT, 'S'}, /* runlevel S is for system initialization */
 		/* On e.g. Debian there exist no boot.d */
 #endif		/* not SUSE */
 };
 
 #define RUNLEVLES (sizeof(runlevel_locations)/sizeof(runlevel_locations[0]))
 
+const int map_has_runlevels(void)
+{
+    return RUNLEVLES;
+}
+
+const char map_runlevel_to_key(const int runlevel)
+{
+    if (runlevel >= RUNLEVLES) {
+        warn("Wrong runlevel %d\n", runlevel);
+    }
+    return runlevel_locations[runlevel].key;
+}
+
+const int map_key_to_lvl(const char key)
+{
+    int runlevel;
+    const char uckey = toupper(key);
+    for (runlevel = 0; runlevel < RUNLEVLES; runlevel++) {
+	if (uckey == runlevel_locations[runlevel].key)
+	    return runlevel_locations[runlevel].lvl;
+    }
+    warn("Wrong runlevel key '%c'\n", uckey);
+    return 0;
+}
+
 static const char *map_runlevel_to_location(const int runlevel)
 {
+    if (runlevel >= RUNLEVLES) {
+	warn("Wrong runlevel %d\n", runlevel);
+    }
     return runlevel_locations[runlevel].location;
 }
 
-#ifndef SUSE
-static const int map_runlevel_to_lvl(const int runlevel)
+const int map_runlevel_to_lvl(const int runlevel)
 {
+    if (runlevel >= RUNLEVLES) {
+	warn("Wrong runlevel %d\n", runlevel);
+	return 0;
+    }
     return runlevel_locations[runlevel].lvl;
 }
 
+#ifndef SUSE
 static const int map_runlevel_to_seek(const int runlevel)
 {
+    if (runlevel >= RUNLEVLES) {
+	warn("Wrong runlevel %d\n", runlevel);
+	return LVL_NORM;
+    }
     return runlevel_locations[runlevel].seek;
 }
 #endif /* not SUSE */
--- insserv-1.09.0~/listing.c	2008-01-04 11:22:09.000000000 +0100
+++ insserv-1.09.0/listing.c	2008-01-04 11:22:09.000000000 +0100
@@ -58,6 +58,9 @@
 #define DIR_LOOP	0x00000002
 #define DIR_ISACTIVE	0x00000004
 
+/* From insserv.c */
+extern const int map_has_runlevels(void);
+extern const int map_runlevel_to_lvl (const int runlevel);
 /*
  * Provide or find a service dir, set initial states and
  * link it into the maintaining if a new one.
@@ -428,24 +431,7 @@
     boolean ret = false;
     unsigned int lvl = 0;
 
-    switch (runlevel) {
-	case 0: lvl = LVL_HALT;   break;
-	case 1: lvl = LVL_ONE;    break;
-	case 2: lvl = LVL_TWO;    break;
-	case 3: lvl = LVL_THREE;  break;
-	case 4: lvl = LVL_FOUR;   break;
-	case 5: lvl = LVL_FIVE;   break;
-	case 6: lvl = LVL_REBOOT; break;
-#ifdef SUSE
-	case 7: lvl = LVL_SINGLE; break;
-	case 8: lvl = LVL_BOOT;   break;
-#else
-	case 7: lvl = LVL_BOOT;   break;
-#endif /* not SUSE */
-
-	default:
-	    warn("Wrong runlevel %d\n", runlevel);
-    }
+    lvl = map_runlevel_to_lvl (runlevel);
 
     list_for_each(tmp, d_start) {
 	dir_t * dir = getdir(tmp);
@@ -480,23 +466,7 @@
     if (!*script)
 	tmp  = d_start->next;
 
-    switch (runlevel) {
-	case 0: lvl = LVL_HALT;   break;
-	case 1: lvl = LVL_ONE;    break;
-	case 2: lvl = LVL_TWO;    break;
-	case 3: lvl = LVL_THREE;  break;
-	case 4: lvl = LVL_FOUR;   break;
-	case 5: lvl = LVL_FIVE;   break;
-	case 6: lvl = LVL_REBOOT; break;
-#ifdef SUSE
-	case 7: lvl = LVL_SINGLE; break;
-	case 8: lvl = LVL_BOOT;	  break;
-#else
-	case 7: lvl = LVL_BOOT;	  break;
-#endif /* not SUSE */
-	default:
-	    warn("Wrong runlevel %d\n", runlevel);
-    }
+    lvl = map_runlevel_to_lvl (runlevel);
 
     do {
 	ret = false;
@@ -587,30 +557,7 @@
 	if (!strpbrk(token, "0123456sSbB"))
 	    continue;
 
-	if (*token == 'S' || *token == 's')
-	    num = 7;
-	else if (*token == 'B' || *token == 'b')
-	    num = 8;
-	else
-	    num = atoi(token);
-
-	switch (num) {
-	    case 0: ret |= LVL_HALT;   break;
-	    case 1: ret |= LVL_ONE;    break;
-	    case 2: ret |= LVL_TWO;    break;
-	    case 3: ret |= LVL_THREE;  break;
-	    case 4: ret |= LVL_FOUR;   break;
-	    case 5: ret |= LVL_FIVE;   break;
-	    case 6: ret |= LVL_REBOOT; break;
-#ifdef SUSE
-	    case 7: ret |= LVL_SINGLE; break;
-	    case 8: ret |= LVL_BOOT;   break;
-#else
-	    case 7: ret |= LVL_BOOT;   break;
-#endif /* not SUSE */
-	    default:
-		warn("Wrong runlevel %d\n", num);
-	}
+        ret |= map_key_to_lvl(*token);
     }
 
     return ret;
