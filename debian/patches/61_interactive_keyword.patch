Purpose: Add support for a X-Interactive keyword to avoid specifying it in insserv.conf
Fixes:   #458224
Status:  Work in progress.
---

Index: insserv/insserv.8.in
===================================================================
--- insserv.orig/insserv.8.in	2009-09-26 22:35:25.000000000 +0200
+++ insserv/insserv.8.in	2009-09-26 22:35:43.000000000 +0200
@@ -76,6 +76,7 @@
  # X-Stop-After:      boot_facility_1 [ boot_facility_2 ...]
  # Default-Start:     run_level_1 [ run_level_2 ...]
  # Default-Stop:      run_level_1 [ run_level_2 ...]
+ # X-Interactive:     true
  # Short-Description: single_line_description
  # Description:       multiline_description
  ### END INIT INFO
@@ -117,6 +118,11 @@
 these tags is stopped.
 @@END_SUSE@@
 .PP
+The optional X\-Interactive keyword implies that the script using this
+keyword should be started alone in a concurrent boot configuration
+because it interact with the user at the console.  Only the value
+`true' is recogniced.  All other are ignored.
+.PP
 The optional
 .B X\-Start\-Before
 keyword implies that the script using this keyword
Index: insserv/insserv.c
===================================================================
--- insserv.orig/insserv.c	2009-09-26 22:35:39.000000000 +0200
+++ insserv/insserv.c	2009-09-26 22:35:43.000000000 +0200
@@ -97,6 +97,7 @@
 #define DEFAULT_START	DEFAULT  START VALUE
 #define DEFAULT_STOP	DEFAULT  STOP  VALUE
 #define DESCRIPTION	COMM "description" VALUE
+#define INTERACTIVE	COMM "x-interactive" VALUE
 
 /* System facility search within /etc/insserv.conf */
 #define EQSIGN		"([[:blank:]]*[=:][[:blank:]]*|[[:blank:]]+)"
@@ -133,6 +134,7 @@
     char *default_start;
     char *default_stop;
     char *description;
+    char *interactive;
 } attribute((aligned(sizeof(char*)))) lsb_t;
 
 /* Search results points here */
@@ -147,6 +149,7 @@
     regex_t def_start;
     regex_t def_stop;
     regex_t desc;
+    regex_t interact;
 } attribute((aligned(sizeof(regex_t)))) reg_t;
 
 typedef struct creg_struct {
@@ -1132,6 +1135,7 @@
     regcompiler(&reg.def_start, DEFAULT_START,  REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.def_stop,  DEFAULT_STOP,   REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
+    regcompiler(&reg.interact,  INTERACTIVE,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
 }
 
 static inline void scan_script_reset(void) attribute((always_inline));
@@ -1147,6 +1151,7 @@
     xreset(script_inf.default_start);
     xreset(script_inf.default_stop);
     xreset(script_inf.description);
+    xreset(script_inf.interactive);
 }
 
 #define FOUND_LSB_HEADER   0x01
@@ -1177,6 +1182,7 @@
 #define default_start	script_inf.default_start
 #define default_stop	script_inf.default_stop
 #define description	script_inf.description
+#define interactive	script_inf.interactive
 
     info("Loading %s\n", path);
 
@@ -1273,6 +1279,14 @@
 		description = empty;
 	}
 
+	if (!interactive    && regexecutor(&reg.interact,      COMMON_ARGS) == true) {
+	    if (val->rm_so < val->rm_eo) {
+		*(pbuf+val->rm_eo) = '\0';
+		interactive = xstrdup(pbuf+val->rm_so);
+	    } else
+		interactive = empty;
+	}
+
 	/* Skip scanning below from LSB magic end */
 	if ((end = strstr(buf, "### END INIT INFO")))
 	    break;
@@ -1341,6 +1355,7 @@
 #undef default_start
 #undef default_stop
 #undef description
+#undef interactive
     return ret;
 }
 
@@ -1503,6 +1518,7 @@
     regfree(&reg.def_start);
     regfree(&reg.def_stop);
     regfree(&reg.desc);
+    regfree(&reg.interact);
 }
 
 static struct {
@@ -1781,6 +1797,9 @@
 		if (script_inf.stop_after && script_inf.stop_after != empty) {
 		    reversereq(service, REQ_SHLD|REQ_KILL, script_inf.stop_after);
 		}
+		if (script_inf.interactive && 0 == strcmp(script_inf.interactive, "true")) {
+		    service->attr.flags |= SERV_INTRACT;
+		}
 	    }
 
 	    if (name) 
@@ -2881,6 +2900,9 @@
 			if (script_inf.should_stop && script_inf.should_stop != empty) {
 			    rememberreq(service, REQ_SHLD|REQ_KILL, script_inf.should_stop);
 			}
+			if (script_inf.interactive && 0 == strcmp(script_inf.interactive, "true")) {
+			    service->attr.flags |= SERV_INTRACT;
+			}
 		    }
 
 		    if (script_inf.start_before && script_inf.start_before != empty) {
