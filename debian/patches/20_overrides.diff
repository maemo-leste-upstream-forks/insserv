--- insserv-1.00.8.orig/insserv.c
+++ insserv-1.00.8/insserv.c
@@ -875,7 +875,7 @@
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
 }
 
-static boolean scan_script_defaults(const char *const path)
+static boolean scan_lsb_headers(const char *const path)
 {
     regmatch_t subloc[SUBNUM_SHD+1], *val = &subloc[SUBNUM-1], *shl = &subloc[SUBNUM_SHD-1];
     FILE *script;
@@ -896,16 +896,6 @@
     if (!script)
 	error("fopen(%s): %s\n", path, strerror(errno));
 
-    /* Reset old results */
-    xreset(provides);
-    xreset(required_start);
-    xreset(required_stop);
-    xreset(should_start);
-    xreset(should_stop);
-    xreset(default_start);
-    xreset(default_stop);
-    xreset(description);
-
 #define COMMON_ARGS	buf, SUBNUM, subloc, 0
 #define COMMON_SHD_ARGS	buf, SUBNUM_SHD, subloc, 0
     while (fgets(buf, sizeof(buf), script)) {
@@ -991,11 +981,80 @@
 #undef default_start
 #undef default_stop
 #undef description
+    return ret;
+}
 
+/*
+ * Follow symlinks, return the basename of the file pointed to by
+ * symlinks or the basename of the current path if no symlink.
+ */
+static char *scriptname(const char *path)
+{
+    char linkbuf[1024];
+    char *script;
+    strncpy(linkbuf, path, sizeof(linkbuf));
+
+    int linklen = readlink(path, linkbuf, sizeof(linkbuf));
+
+    while (-1 != linklen) {
+        char *newpath = strdup(linkbuf);
+	linklen = readlink(newpath, linkbuf, sizeof(linkbuf));
+	free(newpath);
+    }
+    script = basename(linkbuf);
+    return strdup(script);
+}
+
+static boolean load_overrides(const char *const dir,
+			      const char *const name)
+{
+    boolean ret = 0;
+
+    char fullpath[1024];
+    snprintf(fullpath, sizeof(fullpath), "%s/%s", dir, name);
+    struct stat statbuf;
+    if (0 == stat(fullpath, &statbuf) && S_ISREG(statbuf.st_mode)) {
+        ret = scan_lsb_headers(fullpath);
+    }
     return ret;
 }
 
+static boolean scan_script_defaults(const char *const path)
+{
+    boolean ret = 0;
+    boolean override = 0;
+    char *name = scriptname(path);
+
+    /* Reset old results */
+    xreset(script_inf.provides);
+    xreset(script_inf.required_start);
+    xreset(script_inf.required_stop);
+    xreset(script_inf.should_start);
+    xreset(script_inf.should_stop);
+    xreset(script_inf.default_start);
+    xreset(script_inf.default_stop);
+    xreset(script_inf.description);
+
+    /* Load values if the override file exist */
+    override = load_overrides("/usr/share/insserv/overrides", name);
+
+    /* Replace with headers from the script itself */
+    ret = scan_lsb_headers(path);
+
+    /* Allow host-specific overrides to replace the content in the
+       init.d scripts */
+    override |= load_overrides("/etc/insserv/overrides", name);
+
+    if (!ret) {
+        warn("warning: script '%s' missing LSB tags\n", path);
+    }
+    if (!override) {
+        warn("warning: script '%s' missing override too\n", name);
+    }
+    return ret | override;
+}
+
 static inline void scan_script_regfree()
 {
     regfree(&reg.prov);
