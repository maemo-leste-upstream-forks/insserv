--- ./insserv.c	2007-12-29 19:39:07.000000000 +0100
+++ ../insserv-1.10.0/insserv.c	2007-11-21 18:26:47.000000000 +0100
@@ -13,6 +13,8 @@
  * (at your option) any later version.
  */
 
+#define MINIMAL_MAKE	1	/* Remove disabled scripts from .depend.boot,
+				 * .depend.start and .depend.stop */
 #include <pwd.h>
 #include <string.h>
 #include <unistd.h>
@@ -57,12 +59,16 @@
 /* The main regular search expressions */
 #define PROVIDES	COMM "provides" VALUE
 #define REQUIRED	COMM "required"
-#define SHOULD		COMM "(x[-_]+[a-z0-9_-]+)?should"
+#define SHOULD		COMM "(x[-_]+[a-z0-9_-]*)?should"
+#define BEFORE		COMM "(x[-_]+[a-z0-9_-]*)?start[-_]+before"
+#define AFTER		COMM "(x[-_]+[a-z0-9_-]*)?stop[-_]+after"
 #define DEFAULT		COMM "default"
 #define REQUIRED_START  REQUIRED START VALUE
 #define REQUIRED_STOP	REQUIRED STOP  VALUE
 #define SHOULD_START	SHOULD   START VALUE
 #define SHOULD_STOP	SHOULD   STOP  VALUE
+#define START_BEFORE	BEFORE   VALUE
+#define STOP_AFTER	AFTER    VALUE
 #define DEFAULT_START	DEFAULT  START VALUE
 #define DEFAULT_STOP	DEFAULT  STOP  VALUE
 #define DESCRIPTION	COMM "description" VALUE
@@ -74,6 +80,9 @@
 #define SUBCONF		2
 #define SUBCONFNUM	4
 
+/* The root file system */
+static char *root;
+
 /* The main line buffer if unique */
 static char buf[LINE_MAX];
 
@@ -90,6 +99,8 @@
     char *required_stop;
     char *should_start;
     char *should_stop;
+    char *start_before;
+    char *stop_after;
     char *default_start;
     char *default_stop;
     char *description;
@@ -102,6 +113,8 @@
     regex_t req_stop;
     regex_t shl_start;
     regex_t shl_stop;
+    regex_t start_bf;
+    regex_t stop_af;
     regex_t def_start;
     regex_t def_stop;
     regex_t desc;
@@ -283,7 +296,7 @@
 /*
  * Remember requests for required or should services and expand `$' token
  */
-static void rememberreq(serv_t *serv, unsigned int bit, char * required)
+static void rememberreq(serv_t *serv, unsigned int bit, const char * required)
 {
     char * token, * tmp = strdupa(required);
     list_t * ptr;
@@ -297,8 +310,12 @@
 	    continue;
 
 	bit = old;
-again:
+
 	switch(*token) {
+	case '+':
+	    /* This is an optional token */
+	    token++;
+	    bit = REQ_SHLD;
 	default:
 	    list_for_each(ptr, &(serv->sort.req)) {
 		if (!strcmp(getreq(ptr)->serv, token)) {
@@ -332,12 +349,6 @@
 		}
 	    }
 	    break;
-	case '+':
-	    /* This is an optional token */
-	    token++;
-	    bit = REQ_SHLD;
-	    goto again;
-	    break;
 	}
     }
 
@@ -349,6 +360,39 @@
     }
 }
 
+static void reversereq(const serv_t * serv, const char * token, const char * list)
+{
+    const char * dep;
+    char * rev = strdupa(list);
+
+    while ((dep = strsep(&rev, delimeter)) && *dep) {
+	serv_t * tmp;
+	list_t * ptr;
+
+	switch (*dep) {
+	case '+':
+	    dep++;
+	default:
+	    if ((tmp = findserv(dep))) {
+		const char * name;
+		if ((name = getscript(serv->name)) == (char*)0)
+			name = serv->name;
+		rememberreq(tmp, REQ_SHLD, name);
+	    }
+	    requiresv(dep, token);
+	    break;
+	case '$':
+	    list_for_each(ptr, sysfaci_start) {
+		if (!strcmp(dep, getfaci(ptr)->name)) {
+		    reversereq(serv, token, getfaci(ptr)->repl);
+		    break;
+		}
+	    }
+	    break;
+	}
+    }
+}
+
 /*
  * Check required services for name
  */
@@ -650,16 +694,28 @@
     info("creating .depend.boot\n");
     info("creating .depend.start\n");
 
-    name = NULL;
+    name = (char*)0;
     fprintf(boot, "TARGETS =");
-    while (listscripts(&name, LVL_BOOT))
+    while (listscripts(&name, LVL_BOOT)) {
+#if defined(MINIMAL_MAKE) && (MINIMAL_MAKE != 0)
+	const serv_t *serv = findserv(getprovides(name));
+	if (!serv || !(serv->opts & SERV_ENABLED))
+	    continue;
+#endif
 	fprintf(boot, " %s", name);
+    }
     putc('\n', boot);
 
-    name = NULL;
+    name = (char*)0;
     fprintf(start, "TARGETS =");
-    while (listscripts(&name, LVL_ALL))		/* LVL_ALL: nearly all but not BOOT */
+    while (listscripts(&name, LVL_ALL)) {	/* LVL_ALL: nearly all but not BOOT */
+#if defined(MINIMAL_MAKE) && (MINIMAL_MAKE != 0)
+	const serv_t *serv = findserv(getprovides(name));
+	if (!serv || !(serv->opts & SERV_ENABLED))
+	    continue;
+#endif
 	fprintf(start, " %s", name);
+    }
     putc('\n', start);
 
     fprintf(boot,  "INTERACTIVE =");
@@ -667,7 +723,15 @@
     list_for_each(srv, serv_start) {
 	serv_t * cur = getserv(srv);
 
-	if (!cur || list_empty(&(cur->sort.req)))
+#if defined(MINIMAL_MAKE) && (MINIMAL_MAKE != 0)
+	if (!cur || !(cur->opts & SERV_ENABLED))
+	    continue;
+#else
+	if (!cur)
+	    continue;
+#endif
+
+	if (list_empty(&(cur->sort.req)))
 	    continue;
 
 	if (cur->lvls & LVL_BOOT)
@@ -773,10 +837,16 @@
     }
     info("creating .depend.stop\n");
 
-    name = NULL;
+    name = (char*)0;
     fprintf(stop, "TARGETS =");
-    while (listscripts(&name, LVL_NORM))	/* LVL_NORM: nearly all but not BOOT and not SINGLE */
+    while (listscripts(&name, LVL_NORM)) {	/* LVL_NORM: nearly all but not BOOT and not SINGLE */
+#if defined(MINIMAL_MAKE) && (MINIMAL_MAKE != 0)
+	const serv_t *serv = findserv(getprovides(name));
+	if (!serv || !(serv->opts & SERV_ENABLED))
+	    continue;
+#endif
 	fprintf(stop, " %s", name);
+    }
     putc('\n', stop);
 
     list_for_each(srv, serv_start) {
@@ -881,6 +951,26 @@
 }
 
 /*
+ *  Check for script in list.
+ */
+static int curr_argc = -1;
+static inline boolean chkfor(const char *const script, char ** const list, const int cnt)
+{
+    boolean isinc = false;
+    register int c = cnt;
+
+    curr_argc = -1;
+    while (c--) {
+	if (!strcmp(script, list[c])) {
+	    isinc = true;
+	    curr_argc = c;
+	    break;
+	}
+    }
+    return isinc;
+}
+
+/*
  * Open a runlevel directory, if it not
  * exists than create one.
  */
@@ -950,6 +1040,8 @@
     regcompiler(&reg.req_stop,  REQUIRED_STOP,  REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.shl_start, SHOULD_START,   REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.shl_stop,  SHOULD_STOP,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
+    regcompiler(&reg.start_bf,  START_BEFORE,   REG_EXTENDED|REG_ICASE|REG_NEWLINE);
+    regcompiler(&reg.stop_af,   STOP_AFTER,     REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.def_start, DEFAULT_START,  REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.def_stop,  DEFAULT_STOP,   REG_EXTENDED|REG_ICASE|REG_NEWLINE);
     regcompiler(&reg.desc,      DESCRIPTION,    REG_EXTENDED|REG_ICASE|REG_NEWLINE);
@@ -968,6 +1060,8 @@
 #define required_stop	script_inf.required_stop
 #define should_start	script_inf.should_start
 #define should_stop	script_inf.should_stop
+#define start_before	script_inf.start_before
+#define stop_after	script_inf.stop_after
 #define default_start	script_inf.default_start
 #define default_stop	script_inf.default_stop
 #define description	script_inf.description
@@ -983,6 +1077,18 @@
     xreset(required_stop);
     xreset(should_start);
     xreset(should_stop);
+    xreset(start_before);
+    xreset(stop_after);
+    xreset(default_start);
+    xreset(default_stop);
+    xreset(description);
+
+    /* Reset old results */
+    xreset(provides);
+    xreset(required_start);
+    xreset(required_stop);
+    xreset(should_start);
+    xreset(should_stop);
     xreset(default_start);
     xreset(default_stop);
     xreset(description);
@@ -1034,6 +1140,22 @@
 		should_stop = empty;
 	}
 #endif /* not SUSE */
+	if (!start_before && regexecutor(&reg.start_bf,    COMMON_SHD_ARGS) == true) {
+	    if (shl->rm_so < shl->rm_eo) {
+		*(pbuf+shl->rm_eo) = '\0';
+		start_before = xstrdup(pbuf+shl->rm_so);
+	    } else
+		start_before = empty;
+	}
+#ifndef SUSE
+	if (!stop_after  && regexecutor(&reg.stop_af,      COMMON_SHD_ARGS) == true) {
+	    if (shl->rm_so < shl->rm_eo) {
+		*(pbuf+shl->rm_eo) = '\0';
+		stop_after = xstrdup(pbuf+shl->rm_so);
+	    } else
+		stop_after = empty;
+	}
+#endif /* not SUSE */
 	if (!default_start  && regexecutor(&reg.def_start, COMMON_ARGS) == true) {
 	    if (val->rm_so < val->rm_eo) {
 		*(pbuf+val->rm_eo) = '\0';
@@ -1101,6 +1223,8 @@
 #undef required_stop
 #undef should_start
 #undef should_stop
+#undef start_before
+#undef stop_after
 #undef default_start
 #undef default_stop
 #undef description
@@ -1115,6 +1239,8 @@
     regfree(&reg.req_stop);
     regfree(&reg.shl_start);
     regfree(&reg.shl_stop);
+    regfree(&reg.start_bf);
+    regfree(&reg.stop_af);
     regfree(&reg.def_start);
     regfree(&reg.def_stop);
     regfree(&reg.desc);
@@ -1170,13 +1296,13 @@
 /*
  * Scan current service structure
  */
-static void scan_script_locations(const char *const path)
+static void scan_script_locations(const char *const path, char ** const iargv, const int icnt)
 {
     int runlevel;
 
     pushd(path);
     for (runlevel = 0; runlevel < RUNLEVLES; runlevel++) {
-	const char * rcd = NULL;
+	const char * rcd = (char*)0;
 	DIR  * rcdir;
 	struct dirent *d;
 	char * token;
@@ -1184,16 +1310,20 @@
 
 	rcd = map_runlevel_to_location(runlevel);
 	rcdir = openrcdir(rcd); /* Creates runlevel directory if necessary */
-	if (rcdir == NULL)
+	if (rcdir == (DIR*)0)
 	    break;
 	pushd(rcd);
-	while ((d = readdir(rcdir)) != NULL) {
+	while ((d = readdir(rcdir)) != (struct dirent*)0) {
 	    char * ptr = d->d_name;
 	    char order = 0;
-	    char* begin = (char*)NULL; /* Remember address of ptr handled by strsep() */
+	    char* begin = (char*)0;	/* Remember address of ptr handled by strsep() */
 	    boolean lsb;
 
+#ifdef SUSE
 	    if (*ptr != 'S')
+#else
+	    if (*ptr != 'S' && *ptr != 'K')
+#endif
 		continue;
 	    ptr++;
 
@@ -1202,6 +1332,9 @@
 	    order = atoi(ptr);
 	    ptr += 2;
 
+	    if (iargv && chkfor(ptr, iargv, icnt))
+		continue;		/* ignore scripts if removed later */
+
 	    if (stat(d->d_name, &st_script) < 0) {
 		xremove(d->d_name);	/* dangling sym link */
 		continue;
@@ -1234,6 +1367,9 @@
 		    rememberreq(service, REQ_SHLD, script_inf.should_start);
 		    requiresv(token, script_inf.should_start);
 		}
+		if (script_inf.start_before && script_inf.start_before != empty) {
+		    reversereq(service, token, script_inf.start_before);
+		}
 #ifndef SUSE
 		/*
 		 * required_stop and should_stop arn't used in SuSE Linux.
@@ -1248,6 +1384,9 @@
 		    rememberreq(service, REQ_SHLD, script_inf.should_stop);
 		    requiresv(token, script_inf.should_stop);
 		}
+		if (script_inf.stop_after && script_inf.stop_after != empty) {
+		    reversereq(service, token, script_inf.stop_after);
+		}
 #endif /* not SUSE */
 	    }
 	    script_inf.provides = begin;
@@ -1257,6 +1396,8 @@
 	    xreset(script_inf.required_stop);
 	    xreset(script_inf.should_start);
 	    xreset(script_inf.should_stop);
+	    xreset(script_inf.start_before);
+	    xreset(script_inf.stop_after);
 	    xreset(script_inf.default_start);
 	    xreset(script_inf.default_stop);
 	    xreset(script_inf.description);
@@ -1389,29 +1530,56 @@
 	    return 0;
 	}
     }
+    if ((end = strrchr(d->d_name, ','))) {
+	end++;
+	if (!strcmp(end,  "v"))		  /* rcs-files */
+	{
+	    return 0;
+	}
+    }
     return 1;
 }
 
 static void scan_conf()
 {
-    struct dirent** namelist = NULL;
-    const char dir[] = INSCONF ".d";
-    char buf[PATH_MAX];
+    struct dirent** namelist = (struct dirent**)0;
+    char path[PATH_MAX+1];
     int n;
 
-    scan_conf_file(INSCONF);
+    n = snprintf(&path[0], sizeof(path), "%s%s", root ? root : "", INSCONF);
+    if (n >= sizeof(path) || n < 0)
+	error("snprintf(): %s\n", strerror(errno));
+
+    scan_conf_file(path);
 
-    n = scandir(dir, &namelist, cfgfile_filter, alphasort);
+    n = snprintf(&path[0], sizeof(path), "%s%s.d", root ? root : "", INSCONF);
+    if (n >= sizeof(path) || n < 0)
+	error("snprintf(): %s\n", strerror(errno));
+
+    n = scandir(path, &namelist, cfgfile_filter, alphasort);
     if(n > 0)
     {
 	while(n--)
 	{
-	    snprintf(buf, sizeof(buf), "%s/%s", dir, namelist[n]->d_name);
+	    char buf[PATH_MAX+1], * ptr = namelist[n]->d_name;
+	    int r;
+
+	    if ((*ptr == '.') && ((*(ptr+1) == '\0') || (*(ptr+1) == '.'))) {
+		free(namelist[n]);
+		continue;
+	    }
+
+	    r = snprintf(buf, sizeof(buf), "%s/%s", path, namelist[n]->d_name);
+	    if (r >= sizeof(buf) || r < 0)
+		error("snprintf(): %s\n", strerror(errno));
+
 	    scan_conf_file(buf);
+
+	    free(namelist[n]);
 	}
     }
-
-    free(namelist);
+    if (namelist)
+	free(namelist);
 }
 
 /*
@@ -1453,35 +1621,15 @@
     return ret;
 }
 
-/*
- *  Check for script in list.
- */
-static int curr_argc = -1;
-static inline boolean chkfor(const char *const script, char ** const list, const int cnt)
-{
-    boolean isinc = false;
-    register int c = cnt;
-
-    curr_argc = -1;
-    while (c--) {
-	if (!strcmp(script, list[c])) {
-	    isinc = true;
-	    curr_argc = c;
-	    break;
-	}
-    }
-    return isinc;
-}
-
 static struct option long_options[] =
 {
-    {"verbose",	0, NULL, 'v'},
-    {"dryrun",	0, NULL, 'n'},
-    {"default",	0, NULL, 'd'},
-    {"remove",	0, NULL, 'r'},
-    {"force",	0, NULL, 'f'},
-    {"help",	0, NULL, 'h'},
-    { 0,	0, NULL,  0 },
+    {"verbose",	0, (int*)0, 'v'},
+    {"dryrun",	0, (int*)0, 'n'},
+    {"default",	0, (int*)0, 'd'},
+    {"remove",	0, (int*)0, 'r'},
+    {"force",	0, (int*)0, 'f'},
+    {"help",	0, (int*)0, 'h'},
+    { 0,	0, (int*)0,  0 },
 };
 
 static void help(const char *const  name)
@@ -1596,6 +1744,17 @@
 	}
     }
 
+    if (strcmp(path, INITDIR) != 0) {
+	char * tmp;
+	root = xstrdup(path);
+	if ((tmp = strstr(root, INITDIR))) {
+	    *tmp = '\0';
+	} else {
+	    free(root);
+	    root = (char*)0;
+	}
+    }
+
     c = argc;
     while (c--) {
 	char * base;
@@ -1867,7 +2026,7 @@
 		    boolean known = (service->opts & SERV_KNOWN);
 		    service->opts |= SERV_KNOWN;
 
-		    if (!provides && (count > 1)) {		/* Last token */ 
+		    if ((!provides || !*provides) && (count > 1)) { /* Last token */ 
 			const char * script = getscript(service->name);
 
 			if (script) {
@@ -1881,7 +2040,7 @@
 				    continue;
 
 				if (!strcmp(chk, script) && (service != cur)) {
-				    cur->opts |= SERV_DUPLET; 
+				    cur->opts |= SERV_DUPLET;
 				    cur->main = service;	/* Remember main service */
 				}
 			    }
@@ -1913,6 +2072,14 @@
 			}
 #endif /* not SUSE */
 		    }
+		    if (script_inf.start_before && script_inf.start_before != empty) {
+			reversereq(service, token, script_inf.start_before);
+		    }
+#ifndef SUSE
+		    if (script_inf.stop_after && script_inf.stop_after != empty) {
+			reversereq(service, token, script_inf.stop_after);
+		    }
+#endif /* not SUSE */
 		    /*
 		     * Use information from symbolic link structure to
 		     * check if all services are around for this script.
@@ -2082,6 +2249,8 @@
     xreset(script_inf.required_stop);
     xreset(script_inf.should_start);
     xreset(script_inf.should_stop);
+    xreset(script_inf.start_before);
+    xreset(script_inf.stop_after);
     xreset(script_inf.default_start);
     xreset(script_inf.default_stop);
     xreset(script_inf.description);
@@ -2202,6 +2371,7 @@
 
 	while (foreach(&script, &order, runlevel)) {
 	    const boolean this = chkfor(script, argv, argc);
+	    serv_t *serv = findserv(getprovides(script));
 	    boolean found, slink;
 	    char * clink;
 
@@ -2222,8 +2392,10 @@
 		    if (this && !del)
 			xsymlink(olink, nlink);	/* Restore, with correct order */
 		} else {
-		    if (del && this)
+		    if (del && this) {
 			xremove(clink);		/* Found it, remove link */
+			if (serv) serv->opts &= ~SERV_ENABLED;
+		    }
 		}
 	    }
 
@@ -2234,6 +2406,7 @@
 		 */
 		if (!del && !found) {
 		    xsymlink(olink, nlink);
+		    if (serv) serv->opts |= SERV_ENABLED;
 		    found = true;
 		}
 	    }
@@ -2350,8 +2523,8 @@
 	while (listscripts(&script, seek)) {
 	    const boolean stop = notincluded(script, runlevel);
 	    const boolean this = chkfor(script, argv, argc);
-	    const serv_t *serv = findserv(getprovides(script));
 	    const char mode = (stop ? 'K' : 'S');
+	    serv_t *serv = findserv(getprovides(script));
 	    int order = getorder(script);
 	    boolean found;
 	    char * clink;
@@ -2388,8 +2561,10 @@
 		    if (this && !del)
 			xsymlink(olink, nlink);	/* Restore, with correct order */
 		} else {
-		    if (del && this)
+		    if (del && this) {
 			xremove(clink);		/* Found it, remove link */
+			if (serv) serv->opts &= ~SERV_ENABLED;
+		    }
 		}
 	    }
 
@@ -2400,6 +2575,7 @@
 		 */
 		if (!del && !found) {
 		    xsymlink(olink, nlink);
+		    if (serv) serv->opts |= SERV_ENABLED;
 		    found = true;
 		}
 	    }
